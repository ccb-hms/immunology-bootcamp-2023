[
  {
    "objectID": "session-materials/session4/session4.html",
    "href": "session-materials/session4/session4.html",
    "title": "Session 4: Modeling",
    "section": "",
    "text": "Session 4 materials go here"
  },
  {
    "objectID": "session-materials/session3/session3_test.html",
    "href": "session-materials/session3/session3_test.html",
    "title": "session3",
    "section": "",
    "text": "In this session, we will explore the ways to create, manipulate, and export variety of plots such as histograms, boxplots, line plots, and scatter plots.\nR is one of the most versatile platform for data visualization and it can create almost any type of graph. Although there are several ways to create graphs in R, we will particularly focus on “ggplot2” package which is arguably one of the most used package in R.\n\n\n\n\n\nggplot2 uses a language (a.k.a grammar of graphics) to describe how to plot data. To begin with, let’s call a simple data data set and plot it.\n\nlibrary(ggplot2)\n\n\n# load data\n\nlibrary(mosaicData)\n\ndata(CPS85 , package = \"mosaicData\")\n\n\n\n\n\n\n\nNote\n\n\n\nCPS85: Data from the 1985 Current Population Survey (CPS85)\nDescription\nThe Current Population Survey (CPS) is used to supplement census information between census years. These data consist of a random sample of persons from the CPS85, with information on wages and other characteristics of the workers, including sex, number of years of education, years of work experience, occupational status, region of residence and union membership.\nSource: https://www.rdocumentation.org/packages/mosaicData/versions/0.16.0/topics/CPS85\n\n\nThe first function in building a graph is the ggplot function. It specifies the\n\ndata frame containing the data to be plotted\nthe mapping of the variables to visual properties of the graph. The mappings are placed within the aes function (where aes stands for aesthetics).\n\n\nlibrary(ggplot2)\n\nggplot(data = CPS85,\n       mapping = aes(x = exper , y =  wage))\n\n\n\n\nWhy do you think the graph is empty? It is because we haven’t specified what data we want to place on the graph - although we only specified the x and y axes.\n\n\nGeoms are the geometric objects (points, lines, bars, etc.) that can be placed on a graph. They are added using functions that start with geom_. In this example, we’ll add points using the geom_point function, creating a scatterplot.\nIn ggplot2 graphs, functions are chained together using the + sign to build a final plot.\n\n# add points\nggplot(data = CPS85,\n       mapping = aes(x = exper, y = wage)) +\n  geom_point()\n\n\n\n\nThe graph indicates that there is an outlier. One individual has a wage much higher than the rest. We’ll delete this case before continuing. Please re-call what you’ve learned from the previous data-wrangling session.\n\n# delete outlier\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nplotdata &lt;- filter(CPS85, wage &lt; 40)\n\n# redraw scatterplot\nggplot(data = plotdata,\n       mapping = aes(x = exper, y = wage)) +\n  geom_point()\n\n\n\n\nA number of parameters (options) can be specified in a geom_ function. Options for the geom_point function include color, size, and alpha. These control the point color, size, and transparency, respectively. Transparency ranges from 0 (completely transparent) to 1 (completely opaque). Adding a degree of transparency can help visualize overlapping points.\n\n# make points blue, larger, and semi-transparent\nggplot(data = plotdata,\n       mapping = aes(x = exper, y = wage)) +\n  geom_point(color = \"cornflowerblue\",\n             alpha = .7,\n             size = 3)\n\n\n\n\nNext, let’s add a line of best fit. We can do this with the geom_smooth function. Options control the type of line (linear, quadratic, nonparametric), the thickness of the line, the line’s color, and the presence or absence of a confidence interval. Here we request a linear regression (method = lm) line (where lm stands for linear model).\n\n# add a line of best fit.\nggplot(data = plotdata,\n       mapping = aes(x = exper, y = wage)) +\n  geom_point(color = \"cornflowerblue\",\n             alpha = .7,\n             size = 3) +\n  geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nIn addition to mapping variables to the x and y axes, variables can be mapped to the color, shape, size, transparency, and other visual characteristics of geometric objects. This allows groups of observations to be superimposed in a single graph.\nLet’s add sex to the plot and represent it by color.\n\n# indicate sex using color\nggplot(data = plotdata,\n       mapping = aes(x = exper, \n                     y = wage,\n                     color = sex)) +\n  geom_point(alpha = .7,\n             size = 3) +\n  geom_smooth(method = \"lm\", \n              se = FALSE, \n              size = 1.5)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nThe color = sex option is placed in the aes function, because we are mapping a variable to an aesthetic. The geom_smooth option (se = FALSE) was added to suppresses the confidence intervals.\nIt appears that men tend to make more money than women. Additionally, there may be a stronger relationship between experience and wages for men than than for women.\n\n\n\nScales control how variables are mapped to the visual characteristics of the plot. Scale functions (which start with scale_) allow you to modify this mapping. In the next plot, we’ll change the x and y axis scaling, and the colors employed.\n\n# modify the x and y axes and specify the colors to be used\nggplot(data = plotdata,\n       mapping = aes(x = exper, \n                     y = wage,\n                     color = sex)) +\n  geom_point(alpha = .7,\n             size = 3) +\n  geom_smooth(method = \"lm\", \n              se = FALSE, \n              linewidth = 1.5) +\n  scale_x_continuous(breaks = seq(0, 60, 10)) +\n  scale_y_continuous(breaks = seq(0, 30, 5),\n                     label = scales::dollar) +\n  scale_color_manual(values = c(\"indianred3\", \n                                \"cornflowerblue\"))\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nWe’re getting there. The numbers on the x and y axes are better, the y axis uses dollar notation, and the colors are more attractive (IMHO).\nHere is a question. Is the relationship between experience, wages and sex the same for each job sector? Let’s repeat this graph once for each job sector in order to explore this.\n\n\n\nFacets reproduce a graph for each level a given variable (or combination of variables). Facets are created using functions that start with facet_. Here, facets will be defined by the eight levels of the sector variable.\n\n# reproduce plot for each level of job sector\nggplot(data = plotdata,\n       mapping = aes(x = exper, \n                     y = wage,\n                     color = sex)) +\n  geom_point(alpha = .7) +\n  geom_smooth(method = \"lm\", \n              se = FALSE) +\n  scale_x_continuous(breaks = seq(0, 60, 10)) +\n  scale_y_continuous(breaks = seq(0, 30, 5),\n                     label = scales::dollar) +\n  scale_color_manual(values = c(\"indianred3\", \n                                \"cornflowerblue\")) +\n  facet_wrap(~sector)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nGraphs should be easy to interpret and informative labels are a key element in achieving this goal. The labs function provides customized labels for the axes and legends. Additionally, a custom title, subtitle, and caption can be added.\n\n# add informative labels\nggplot(data = plotdata,\n       mapping = aes(x = exper, \n                     y = wage,\n                     color = sex)) +\n  geom_point(alpha = .7) +\n  geom_smooth(method = \"lm\", \n              se = FALSE) +\n  scale_x_continuous(breaks = seq(0, 60, 10)) +\n  scale_y_continuous(breaks = seq(0, 30, 5),\n                     label = scales::dollar) +\n  scale_color_manual(values = c(\"indianred3\", \n                                \"cornflowerblue\")) +\n  facet_wrap(~sector) +\n  labs(title = \"Relationship between wages and experience\",\n       subtitle = \"Current Population Survey\",\n       caption = \"source: http://mosaic-web.org/\",\n       x = \" Years of Experience\",\n       y = \"Hourly Wage\",\n       color = \"Gender\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nFinally, we can fine tune the appearance of the graph using themes. Theme functions (which start with theme_) control background colors, fonts, grid-lines, legend placement, and other non-data related features of the graph. Let’s use a cleaner theme.\n\nggplot(data = plotdata,\n       mapping = aes(x = exper, \n                     y = wage,\n                     color = sex)) +\n  geom_point(alpha = .6) +\n  geom_smooth(method = \"lm\", \n              se = FALSE) +\n  scale_x_continuous(breaks = seq(0, 60, 10)) +\n  scale_y_continuous(breaks = seq(0, 30, 5),\n                     label = scales::dollar) +\n  scale_color_manual(values = c(\"indianred3\", \n                                \"cornflowerblue\")) +\n  facet_wrap(~sector) +\n  labs(title = \"Relationship between wages and experience\",\n       subtitle = \"Current Population Survey\",\n       caption = \"source: http://mosaic-web.org/\",\n       x = \" Years of Experience\",\n       y = \"Hourly Wage\",\n       color = \"Gender\") +\n  theme_minimal()\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "session-materials/session3/session3_test.html#introduction-to-ggplot2-grammar",
    "href": "session-materials/session3/session3_test.html#introduction-to-ggplot2-grammar",
    "title": "session3",
    "section": "",
    "text": "ggplot2 uses a language (a.k.a grammar of graphics) to describe how to plot data. To begin with, let’s call a simple data data set and plot it.\n\nlibrary(ggplot2)\n\n\n# load data\n\nlibrary(mosaicData)\n\ndata(CPS85 , package = \"mosaicData\")\n\n\n\n\n\n\n\nNote\n\n\n\nCPS85: Data from the 1985 Current Population Survey (CPS85)\nDescription\nThe Current Population Survey (CPS) is used to supplement census information between census years. These data consist of a random sample of persons from the CPS85, with information on wages and other characteristics of the workers, including sex, number of years of education, years of work experience, occupational status, region of residence and union membership.\nSource: https://www.rdocumentation.org/packages/mosaicData/versions/0.16.0/topics/CPS85\n\n\nThe first function in building a graph is the ggplot function. It specifies the\n\ndata frame containing the data to be plotted\nthe mapping of the variables to visual properties of the graph. The mappings are placed within the aes function (where aes stands for aesthetics).\n\n\nlibrary(ggplot2)\n\nggplot(data = CPS85,\n       mapping = aes(x = exper , y =  wage))\n\n\n\n\nWhy do you think the graph is empty? It is because we haven’t specified what data we want to place on the graph - although we only specified the x and y axes.\n\n\nGeoms are the geometric objects (points, lines, bars, etc.) that can be placed on a graph. They are added using functions that start with geom_. In this example, we’ll add points using the geom_point function, creating a scatterplot.\nIn ggplot2 graphs, functions are chained together using the + sign to build a final plot.\n\n# add points\nggplot(data = CPS85,\n       mapping = aes(x = exper, y = wage)) +\n  geom_point()\n\n\n\n\nThe graph indicates that there is an outlier. One individual has a wage much higher than the rest. We’ll delete this case before continuing. Please re-call what you’ve learned from the previous data-wrangling session.\n\n# delete outlier\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nplotdata &lt;- filter(CPS85, wage &lt; 40)\n\n# redraw scatterplot\nggplot(data = plotdata,\n       mapping = aes(x = exper, y = wage)) +\n  geom_point()\n\n\n\n\nA number of parameters (options) can be specified in a geom_ function. Options for the geom_point function include color, size, and alpha. These control the point color, size, and transparency, respectively. Transparency ranges from 0 (completely transparent) to 1 (completely opaque). Adding a degree of transparency can help visualize overlapping points.\n\n# make points blue, larger, and semi-transparent\nggplot(data = plotdata,\n       mapping = aes(x = exper, y = wage)) +\n  geom_point(color = \"cornflowerblue\",\n             alpha = .7,\n             size = 3)\n\n\n\n\nNext, let’s add a line of best fit. We can do this with the geom_smooth function. Options control the type of line (linear, quadratic, nonparametric), the thickness of the line, the line’s color, and the presence or absence of a confidence interval. Here we request a linear regression (method = lm) line (where lm stands for linear model).\n\n# add a line of best fit.\nggplot(data = plotdata,\n       mapping = aes(x = exper, y = wage)) +\n  geom_point(color = \"cornflowerblue\",\n             alpha = .7,\n             size = 3) +\n  geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nIn addition to mapping variables to the x and y axes, variables can be mapped to the color, shape, size, transparency, and other visual characteristics of geometric objects. This allows groups of observations to be superimposed in a single graph.\nLet’s add sex to the plot and represent it by color.\n\n# indicate sex using color\nggplot(data = plotdata,\n       mapping = aes(x = exper, \n                     y = wage,\n                     color = sex)) +\n  geom_point(alpha = .7,\n             size = 3) +\n  geom_smooth(method = \"lm\", \n              se = FALSE, \n              size = 1.5)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nThe color = sex option is placed in the aes function, because we are mapping a variable to an aesthetic. The geom_smooth option (se = FALSE) was added to suppresses the confidence intervals.\nIt appears that men tend to make more money than women. Additionally, there may be a stronger relationship between experience and wages for men than than for women.\n\n\n\nScales control how variables are mapped to the visual characteristics of the plot. Scale functions (which start with scale_) allow you to modify this mapping. In the next plot, we’ll change the x and y axis scaling, and the colors employed.\n\n# modify the x and y axes and specify the colors to be used\nggplot(data = plotdata,\n       mapping = aes(x = exper, \n                     y = wage,\n                     color = sex)) +\n  geom_point(alpha = .7,\n             size = 3) +\n  geom_smooth(method = \"lm\", \n              se = FALSE, \n              linewidth = 1.5) +\n  scale_x_continuous(breaks = seq(0, 60, 10)) +\n  scale_y_continuous(breaks = seq(0, 30, 5),\n                     label = scales::dollar) +\n  scale_color_manual(values = c(\"indianred3\", \n                                \"cornflowerblue\"))\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nWe’re getting there. The numbers on the x and y axes are better, the y axis uses dollar notation, and the colors are more attractive (IMHO).\nHere is a question. Is the relationship between experience, wages and sex the same for each job sector? Let’s repeat this graph once for each job sector in order to explore this.\n\n\n\nFacets reproduce a graph for each level a given variable (or combination of variables). Facets are created using functions that start with facet_. Here, facets will be defined by the eight levels of the sector variable.\n\n# reproduce plot for each level of job sector\nggplot(data = plotdata,\n       mapping = aes(x = exper, \n                     y = wage,\n                     color = sex)) +\n  geom_point(alpha = .7) +\n  geom_smooth(method = \"lm\", \n              se = FALSE) +\n  scale_x_continuous(breaks = seq(0, 60, 10)) +\n  scale_y_continuous(breaks = seq(0, 30, 5),\n                     label = scales::dollar) +\n  scale_color_manual(values = c(\"indianred3\", \n                                \"cornflowerblue\")) +\n  facet_wrap(~sector)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nGraphs should be easy to interpret and informative labels are a key element in achieving this goal. The labs function provides customized labels for the axes and legends. Additionally, a custom title, subtitle, and caption can be added.\n\n# add informative labels\nggplot(data = plotdata,\n       mapping = aes(x = exper, \n                     y = wage,\n                     color = sex)) +\n  geom_point(alpha = .7) +\n  geom_smooth(method = \"lm\", \n              se = FALSE) +\n  scale_x_continuous(breaks = seq(0, 60, 10)) +\n  scale_y_continuous(breaks = seq(0, 30, 5),\n                     label = scales::dollar) +\n  scale_color_manual(values = c(\"indianred3\", \n                                \"cornflowerblue\")) +\n  facet_wrap(~sector) +\n  labs(title = \"Relationship between wages and experience\",\n       subtitle = \"Current Population Survey\",\n       caption = \"source: http://mosaic-web.org/\",\n       x = \" Years of Experience\",\n       y = \"Hourly Wage\",\n       color = \"Gender\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\nFinally, we can fine tune the appearance of the graph using themes. Theme functions (which start with theme_) control background colors, fonts, grid-lines, legend placement, and other non-data related features of the graph. Let’s use a cleaner theme.\n\nggplot(data = plotdata,\n       mapping = aes(x = exper, \n                     y = wage,\n                     color = sex)) +\n  geom_point(alpha = .6) +\n  geom_smooth(method = \"lm\", \n              se = FALSE) +\n  scale_x_continuous(breaks = seq(0, 60, 10)) +\n  scale_y_continuous(breaks = seq(0, 30, 5),\n                     label = scales::dollar) +\n  scale_color_manual(values = c(\"indianred3\", \n                                \"cornflowerblue\")) +\n  facet_wrap(~sector) +\n  labs(title = \"Relationship between wages and experience\",\n       subtitle = \"Current Population Survey\",\n       caption = \"source: http://mosaic-web.org/\",\n       x = \" Years of Experience\",\n       y = \"Hourly Wage\",\n       color = \"Gender\") +\n  theme_minimal()\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "session-materials/session2/session2.html",
    "href": "session-materials/session2/session2.html",
    "title": "Session 2: Functions and Data Wrangling",
    "section": "",
    "text": "A key feature of R is functions. Functions are “self contained” modules of code that accomplish a specific task. Functions usually take in some sort of data structure (value, vector, dataframe etc.), process it, and return a result.\nThe general usage for a function is the name of the function followed by parentheses:\nfunction_name(input)\nThe input(s) are called arguments, which can include:\n\nthe physical object (any data structure) on which the function carries out a task\nspecifications that alter the way the function operates (e.g. options)\n\nNot all functions take arguments, for example:\ngetwd()\nHowever, most functions can take several arguments. If you don’t specify a required argument when calling the function, you will either receive an error or the function will fall back on using a default.\nThe defaults represent standard values that the author of the function specified as being “good enough in standard cases”. An example would be what symbol to use in a plot. However, if you want something specific, simply change the argument yourself with a value of your choice.\n\n\n\nWe have already used a few examples of basic functions in the previous lessons i.e getwd(), c(), and factor(). These functions are available as part of R’s built in capabilities, and we will explore a few more of these base functions below.\nLet’s revisit a function that we have used previously to combine data c() into vectors. The arguments it takes is a collection of numbers, characters or strings (separated by a comma). The c() function performs the task of combining the numbers or characters into a single vector. You can also use the function to add elements to an existing vector:\n\nglengths &lt;- c(4.6, 3000, 50000)\nglengths &lt;- c(glengths, 90) # adding at the end \nglengths &lt;- c(30, glengths) # adding at the beginning\n\nWhat happens here is that we take the original vector glengths (containing three elements), and we are adding another item to either end. We can do this over and over again to build a vector or a dataset.\nSince R is used for statistical computing, many of the base functions involve mathematical operations. One example would be the function sqrt(). The input/argument must be a number, and the output is the square root of that number. Let’s try finding the square root of 81:\n\nsqrt(81)\n\n[1] 9\n\n\nNow what would happen if we called the function (e.g. ran the function), on a vector of values instead of a single value?\n\nsqrt(glengths)\n\n[1]   5.477226   2.144761  54.772256 223.606798   9.486833\n\n\nIn this case the task was performed on each individual value of the vector glengths and the respective results were displayed.\nLet’s try another function, this time using one that we can change some of the options (arguments that change the behavior of the function), for example round:\n\nround(3.14159)\n\n[1] 3\n\n\nWe can see that we get 3. That’s because the default is to round to the nearest whole number. What if we want a different number of significant digits? Let’s first learn how to find available arguments for a function.\n\n\n\nThe best way of finding out this information is to use the ? followed by the name of the function. Doing this will open up the help manual in the bottom right panel of RStudio that will provide a description of the function, usage, arguments, details, and examples:\n?round\nAlternatively, if you are familiar with the function but just need to remind yourself of the names of the arguments, you can use:\n\nargs(round)\n\nfunction (x, digits = 0) \nNULL\n\n\nEven more useful is the example() function. This will allow you to run the examples section from the Online Help to see exactly how it works when executing the commands. Let’s try that for round():\n\nexample(\"round\")\n\n\nround&gt; round(.5 + -2:4) # IEEE / IEC rounding: -2  0  0  2  2  4  4\n[1] -2  0  0  2  2  4  4\n\nround&gt; ## (this is *good* behaviour -- do *NOT* report it as bug !)\nround&gt; \nround&gt; ( x1 &lt;- seq(-2, 4, by = .5) )\n [1] -2.0 -1.5 -1.0 -0.5  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0\n\nround&gt; round(x1) #-- IEEE / IEC rounding !\n [1] -2 -2 -1  0  0  0  1  2  2  2  3  4  4\n\nround&gt; x1[trunc(x1) != floor(x1)]\n[1] -1.5 -0.5\n\nround&gt; x1[round(x1) != floor(x1 + .5)]\n[1] -1.5  0.5  2.5\n\nround&gt; (non.int &lt;- ceiling(x1) != floor(x1))\n [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n[13] FALSE\n\nround&gt; x2 &lt;- pi * 100^(-1:3)\n\nround&gt; round(x2, 3)\n[1]       0.031       3.142     314.159   31415.927 3141592.654\n\nround&gt; signif(x2, 3)\n[1] 3.14e-02 3.14e+00 3.14e+02 3.14e+04 3.14e+06\n\n\nIn our example, we can change the number of digits returned by adding an argument. We can type digits=2 or however many we may want:\n\nround(3.14159, digits=2)\n\n[1] 3.14\n\n\n\nNOTE: If you provide the arguments in the exact same order as they are defined (in the help manual) you don’t have to name them:\nround(3.14159, 2)\nHowever, it’s usually not recommended practice because it involves a lot of memorization. In addition, it makes your code difficult to read for your future self and others, especially if your code includes functions that are not commonly used. (It’s however OK to not include the names of the arguments for basic functions like mean, min, etc…). Another advantage of naming arguments, is that the order doesn’t matter. This is useful when a function has many arguments.\n\nExercise\n\n\n\n\n\n\nBasic\n\n\n\n\nLet’s use base R function to calculate mean value of the glengths vector. You might need to search online to find what function can perform this task.\nCreate a new vector test &lt;- c(1, NA, 2, 3, NA, 4). Use the same base R function from exercise 1 (with addition of proper argument), and calculate mean value of the test vector. The output should be 2.5. &gt; NOTE: In R, missing values are represented by the symbol NA (not available). It’s a way to make sure that users know they have missing data, and make a conscious decision on how to deal with it. There are ways to ignore NA during statistical calculation, or to remove NA from the vector. If you want more information related to missing data or NA you can go to this page (please note that there are many advanced concepts on that page that have not been covered in class).\nAnother commonly used base function is sort(). Use this function to sort the glengths vector in descending order.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Setup\nglengths &lt;- c(4.6, 3000, 50000)\nglengths &lt;- c(glengths, 90) # adding at the end \nglengths &lt;- c(30, glengths) # adding at the beginning\n\n# Basic \n# 1\nmean(glengths)\n\n[1] 10624.92\n\n# 2\ntest &lt;- c(1, NA, 2, 3, NA, 4)\nmean(test, na.rm=TRUE)\n\n[1] 2.5\n\n# 3\nsort(glengths, decreasing = TRUE)\n\n[1] 50000.0  3000.0    90.0    30.0     4.6\n\n\n\n\n\n\n\n\n\n\n\nAdvanced\n\n\n\n\nUse rnorm and the matrix functions to create a random square matrix with \\(6\\) rows/columns.\nCalculate the mean of each row in the matrix, so you should have 6 means total.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# We need to sample a length 36 vector, then coerce it into a matrix\nmy_matrix &lt;- matrix(rnorm(36), nrow=6)\n\n# There's a built-in function called rowMeans! It's always good to look things up. \nrowMeans(my_matrix)\n\n[1]  0.0969043  0.5473584  0.1985713  0.4773305 -0.3359885 -0.2565272\n\n# We could also use apply to call mean on each row of the matrix\napply(my_matrix, 1, mean)\n\n[1]  0.0969043  0.5473584  0.1985713  0.4773305 -0.3359885 -0.2565272\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\n\nCreate vector c_data &lt;- c(1, NA, 2, 3, NA, 4, 4, 3, 2, NA, NA, 2, 4, 2, 3, 4, 4, 2, 1, NA, 1, 1, 1). Fill in the NA values with the mean of all non-missing values.\nRe-create the vector with its NAs. Instead of filling in the missing data with the mean, estimate the parameter of a Poisson distribution from the data and sample from it to fill in the missing data.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# 1\nc_data &lt;- c(1, NA, 2, 3, NA, 4, 4, 3, 2, NA, NA, 2, 4, 2, 3, 4, 4, 2, 1, NA, 1, 1, 1)\nc_data[is.na(c_data)] &lt;- mean(c_data, na.rm = TRUE)\n\n# 2\nc_data &lt;- c(1, NA, 2, 3, NA, 4, 4, 3, 2, NA, NA, 2, 4, 2, 3, 4, 4, 2, 1, NA, 1, 1, 1)\n\n# We need this to calculate how many numbers we need to sample\nnum_na &lt;- sum(is.na(c_data)) \n# A poisson distribution is paramaterized by it's mean. \n# so we just need the mean of the data to model\nnew_vals &lt;- rpois(num_na, mean(c_data, na.rm = TRUE))\n# And finally, we can index the data to set the sampled values equal to it\nc_data[is.na(c_data)] &lt;- new_vals\n\n\n\n\n\n\n\n\nOne of the great strengths of R is the user’s ability to add functions. Sometimes there is a small task (or series of tasks) you need done and you find yourself having to repeat it multiple times. In these types of situations, it can be helpful to create your own custom function. The structure of a function is given below:\nname_of_function &lt;- function(argument1, argument2) {\n    statements or code that does something\n    return(something)\n}\n\nFirst you give your function a name.\nThen you assign value to it, where the value is the function.\n\nWhen defining the function you will want to provide the list of arguments required (inputs and/or options to modify behaviour of the function), and wrapped between curly brackets place the tasks that are being executed on/using those arguments. The argument(s) can be any type of object (like a scalar, a matrix, a dataframe, a vector, a logical, etc), and it’s not necessary to define what it is in any way.\nFinally, you can “return” the value of the object from the function, meaning pass the value of it into the global environment. The important idea behind functions is that objects that are created within the function are local to the environment of the function – they don’t exist outside of the function.\nLet’s try creating a simple example function. This function will take in a numeric value as input, and return the squared value.\n\nsquare_it &lt;- function(x) {\n    square &lt;- x * x\n    return(square)\n}\n\nOnce you run the code, you should see a function named square_it in the Environment panel (located at the top right of Rstudio interface). Now, we can use this function as any other base R functions. We type out the name of the function, and inside the parentheses we provide a numeric value x:\n\nsquare_it(5)\n\n[1] 25\n\n\nPretty simple, right? In this case, we only had one line of code that was run, but in theory you could have many lines of code to get obtain the final results that you want to “return” to the user.\n\n\nIn the example above, we created a new variable called square inside the function, and then return the value of square. If you don’t use return(), by default R will return the value of the last line of code inside that function. That is to say, the following function will also work.\n\nsquare_it &lt;- function(x) {\n   x * x\n}\n\nHowever, we recommend always using return at the end of a function as the best practice.\n\nWe have only scratched the surface here when it comes to creating functions! We will revisit this in later lessons, but if interested you can also find more detailed information on this R-bloggers site, which is where we adapted this example from.\nExercise\n\n\n\n\n\n\nBasic\n\n\n\n\nLet’s create a function temp_conv(), which converts the temperature in Fahrenheit (input) to the temperature in Kelvin (output).\n\nWe could perform a two-step calculation: first convert from Fahrenheit to Celsius, and then convert from Celsius to Kelvin.\nThe formula for these two calculations are as follows: temp_c = (temp_f - 32) * 5 / 9; temp_k = temp_c + 273.15. To test your function,\nif your input is 70, the result of temp_conv(70) should be 294.2611.\n\nNow we want to round the temperature in Kelvin (output of temp_conv()) to a single decimal place. Use the round() function with the newly-created temp_conv() function to achieve this in one line of code. If your input is 70, the output should now be 294.3.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Basic\n\n# 1\ntemp_conv &lt;- function(temp_f) {\n  temp_c = (temp_f - 32) * 5 / 9\n  temp_k = temp_c + 273.15\n  return (temp_k)\n}\n\n# 2\nround(temp_conv(70), digits = 1)\n\n[1] 294.3\n\n\n\n\n\n\n\n\n\n\n\nAdvanced\n\n\n\nThe Fibonacci sequence is \\(0, 1, 1, 2, 3, 5, 8, ...\\) where the first two terms are 0 and 1, and for all other terms \\(n^{th}\\) term is the sum of the \\((n-1)^{th}\\) and \\((n-2)^{th}\\) terms. Note that for n=0 you should return 0 and for n=1 you should return 1 as the first 2 terms.\n\nWrite a function fibonacci which takes in a single integer argument n and returns the \\(n^{th}\\) term in the Fibonacci sequence.\nHave your function stop with an appropriate message if the argument n is not an integer. Stop allows you to create your own errors in R. This StackOverflow thread contains useful information on how to tell if something is or is not an integer in R.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Advanced\nfibonacci &lt;- function(n){\n  \n  # These next 3 lines are part 2\n  if((n %% 1)!=0){\n    stop(\"Must provide an integer to fibonacci\")\n  }\n  fibs &lt;- c(0,1)\n  for (i in 2:n){\n    fibs &lt;- c(fibs, fibs[i-1]+fibs[i])\n  }\n  return(fibs[n+1])\n}\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nRe-write your fibonacci function so that it calculates the Fibonacci sequence recursively, meaning that it calls itself. Your function should contain no loops or iterative code.\nYou will need to define two base cases, where the function does not call itself.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n#Challenge\nfibonacci2 &lt;- function(n){\n  if((n %% 1)!=0){\n    stop(\"Must provide an integer to fibonacci\")\n  }\n  # We call these two if statement the 'base cases' of the recursion\n  if (n==0){\n    return(0)\n  }\n  if (n==1){\n    return(1)\n  }\n  # And this is the recursive case, where the function calls itself\n  return(fibonacci2(n-1)+fibonacci2(n-2))\n}\n\nRecursion isn’t relevant to most data analysis, as it is often significantly slower than a non-recursive solution in most programming languages.\nHowever, setting up a solution as recursive sometimes allows us to perform an algorithmic strategy called dynamic programming and is fundamental to most sequence alignment algorithms."
  },
  {
    "objectID": "session-materials/session2/session2.html#functions-and-their-arguments",
    "href": "session-materials/session2/session2.html#functions-and-their-arguments",
    "title": "Session 2: Functions and Data Wrangling",
    "section": "",
    "text": "A key feature of R is functions. Functions are “self contained” modules of code that accomplish a specific task. Functions usually take in some sort of data structure (value, vector, dataframe etc.), process it, and return a result.\nThe general usage for a function is the name of the function followed by parentheses:\nfunction_name(input)\nThe input(s) are called arguments, which can include:\n\nthe physical object (any data structure) on which the function carries out a task\nspecifications that alter the way the function operates (e.g. options)\n\nNot all functions take arguments, for example:\ngetwd()\nHowever, most functions can take several arguments. If you don’t specify a required argument when calling the function, you will either receive an error or the function will fall back on using a default.\nThe defaults represent standard values that the author of the function specified as being “good enough in standard cases”. An example would be what symbol to use in a plot. However, if you want something specific, simply change the argument yourself with a value of your choice.\n\n\n\nWe have already used a few examples of basic functions in the previous lessons i.e getwd(), c(), and factor(). These functions are available as part of R’s built in capabilities, and we will explore a few more of these base functions below.\nLet’s revisit a function that we have used previously to combine data c() into vectors. The arguments it takes is a collection of numbers, characters or strings (separated by a comma). The c() function performs the task of combining the numbers or characters into a single vector. You can also use the function to add elements to an existing vector:\n\nglengths &lt;- c(4.6, 3000, 50000)\nglengths &lt;- c(glengths, 90) # adding at the end \nglengths &lt;- c(30, glengths) # adding at the beginning\n\nWhat happens here is that we take the original vector glengths (containing three elements), and we are adding another item to either end. We can do this over and over again to build a vector or a dataset.\nSince R is used for statistical computing, many of the base functions involve mathematical operations. One example would be the function sqrt(). The input/argument must be a number, and the output is the square root of that number. Let’s try finding the square root of 81:\n\nsqrt(81)\n\n[1] 9\n\n\nNow what would happen if we called the function (e.g. ran the function), on a vector of values instead of a single value?\n\nsqrt(glengths)\n\n[1]   5.477226   2.144761  54.772256 223.606798   9.486833\n\n\nIn this case the task was performed on each individual value of the vector glengths and the respective results were displayed.\nLet’s try another function, this time using one that we can change some of the options (arguments that change the behavior of the function), for example round:\n\nround(3.14159)\n\n[1] 3\n\n\nWe can see that we get 3. That’s because the default is to round to the nearest whole number. What if we want a different number of significant digits? Let’s first learn how to find available arguments for a function.\n\n\n\nThe best way of finding out this information is to use the ? followed by the name of the function. Doing this will open up the help manual in the bottom right panel of RStudio that will provide a description of the function, usage, arguments, details, and examples:\n?round\nAlternatively, if you are familiar with the function but just need to remind yourself of the names of the arguments, you can use:\n\nargs(round)\n\nfunction (x, digits = 0) \nNULL\n\n\nEven more useful is the example() function. This will allow you to run the examples section from the Online Help to see exactly how it works when executing the commands. Let’s try that for round():\n\nexample(\"round\")\n\n\nround&gt; round(.5 + -2:4) # IEEE / IEC rounding: -2  0  0  2  2  4  4\n[1] -2  0  0  2  2  4  4\n\nround&gt; ## (this is *good* behaviour -- do *NOT* report it as bug !)\nround&gt; \nround&gt; ( x1 &lt;- seq(-2, 4, by = .5) )\n [1] -2.0 -1.5 -1.0 -0.5  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0\n\nround&gt; round(x1) #-- IEEE / IEC rounding !\n [1] -2 -2 -1  0  0  0  1  2  2  2  3  4  4\n\nround&gt; x1[trunc(x1) != floor(x1)]\n[1] -1.5 -0.5\n\nround&gt; x1[round(x1) != floor(x1 + .5)]\n[1] -1.5  0.5  2.5\n\nround&gt; (non.int &lt;- ceiling(x1) != floor(x1))\n [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n[13] FALSE\n\nround&gt; x2 &lt;- pi * 100^(-1:3)\n\nround&gt; round(x2, 3)\n[1]       0.031       3.142     314.159   31415.927 3141592.654\n\nround&gt; signif(x2, 3)\n[1] 3.14e-02 3.14e+00 3.14e+02 3.14e+04 3.14e+06\n\n\nIn our example, we can change the number of digits returned by adding an argument. We can type digits=2 or however many we may want:\n\nround(3.14159, digits=2)\n\n[1] 3.14\n\n\n\nNOTE: If you provide the arguments in the exact same order as they are defined (in the help manual) you don’t have to name them:\nround(3.14159, 2)\nHowever, it’s usually not recommended practice because it involves a lot of memorization. In addition, it makes your code difficult to read for your future self and others, especially if your code includes functions that are not commonly used. (It’s however OK to not include the names of the arguments for basic functions like mean, min, etc…). Another advantage of naming arguments, is that the order doesn’t matter. This is useful when a function has many arguments.\n\nExercise\n\n\n\n\n\n\nBasic\n\n\n\n\nLet’s use base R function to calculate mean value of the glengths vector. You might need to search online to find what function can perform this task.\nCreate a new vector test &lt;- c(1, NA, 2, 3, NA, 4). Use the same base R function from exercise 1 (with addition of proper argument), and calculate mean value of the test vector. The output should be 2.5. &gt; NOTE: In R, missing values are represented by the symbol NA (not available). It’s a way to make sure that users know they have missing data, and make a conscious decision on how to deal with it. There are ways to ignore NA during statistical calculation, or to remove NA from the vector. If you want more information related to missing data or NA you can go to this page (please note that there are many advanced concepts on that page that have not been covered in class).\nAnother commonly used base function is sort(). Use this function to sort the glengths vector in descending order.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Setup\nglengths &lt;- c(4.6, 3000, 50000)\nglengths &lt;- c(glengths, 90) # adding at the end \nglengths &lt;- c(30, glengths) # adding at the beginning\n\n# Basic \n# 1\nmean(glengths)\n\n[1] 10624.92\n\n# 2\ntest &lt;- c(1, NA, 2, 3, NA, 4)\nmean(test, na.rm=TRUE)\n\n[1] 2.5\n\n# 3\nsort(glengths, decreasing = TRUE)\n\n[1] 50000.0  3000.0    90.0    30.0     4.6\n\n\n\n\n\n\n\n\n\n\n\nAdvanced\n\n\n\n\nUse rnorm and the matrix functions to create a random square matrix with \\(6\\) rows/columns.\nCalculate the mean of each row in the matrix, so you should have 6 means total.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# We need to sample a length 36 vector, then coerce it into a matrix\nmy_matrix &lt;- matrix(rnorm(36), nrow=6)\n\n# There's a built-in function called rowMeans! It's always good to look things up. \nrowMeans(my_matrix)\n\n[1]  0.0969043  0.5473584  0.1985713  0.4773305 -0.3359885 -0.2565272\n\n# We could also use apply to call mean on each row of the matrix\napply(my_matrix, 1, mean)\n\n[1]  0.0969043  0.5473584  0.1985713  0.4773305 -0.3359885 -0.2565272\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\n\nCreate vector c_data &lt;- c(1, NA, 2, 3, NA, 4, 4, 3, 2, NA, NA, 2, 4, 2, 3, 4, 4, 2, 1, NA, 1, 1, 1). Fill in the NA values with the mean of all non-missing values.\nRe-create the vector with its NAs. Instead of filling in the missing data with the mean, estimate the parameter of a Poisson distribution from the data and sample from it to fill in the missing data.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# 1\nc_data &lt;- c(1, NA, 2, 3, NA, 4, 4, 3, 2, NA, NA, 2, 4, 2, 3, 4, 4, 2, 1, NA, 1, 1, 1)\nc_data[is.na(c_data)] &lt;- mean(c_data, na.rm = TRUE)\n\n# 2\nc_data &lt;- c(1, NA, 2, 3, NA, 4, 4, 3, 2, NA, NA, 2, 4, 2, 3, 4, 4, 2, 1, NA, 1, 1, 1)\n\n# We need this to calculate how many numbers we need to sample\nnum_na &lt;- sum(is.na(c_data)) \n# A poisson distribution is paramaterized by it's mean. \n# so we just need the mean of the data to model\nnew_vals &lt;- rpois(num_na, mean(c_data, na.rm = TRUE))\n# And finally, we can index the data to set the sampled values equal to it\nc_data[is.na(c_data)] &lt;- new_vals\n\n\n\n\n\n\n\n\nOne of the great strengths of R is the user’s ability to add functions. Sometimes there is a small task (or series of tasks) you need done and you find yourself having to repeat it multiple times. In these types of situations, it can be helpful to create your own custom function. The structure of a function is given below:\nname_of_function &lt;- function(argument1, argument2) {\n    statements or code that does something\n    return(something)\n}\n\nFirst you give your function a name.\nThen you assign value to it, where the value is the function.\n\nWhen defining the function you will want to provide the list of arguments required (inputs and/or options to modify behaviour of the function), and wrapped between curly brackets place the tasks that are being executed on/using those arguments. The argument(s) can be any type of object (like a scalar, a matrix, a dataframe, a vector, a logical, etc), and it’s not necessary to define what it is in any way.\nFinally, you can “return” the value of the object from the function, meaning pass the value of it into the global environment. The important idea behind functions is that objects that are created within the function are local to the environment of the function – they don’t exist outside of the function.\nLet’s try creating a simple example function. This function will take in a numeric value as input, and return the squared value.\n\nsquare_it &lt;- function(x) {\n    square &lt;- x * x\n    return(square)\n}\n\nOnce you run the code, you should see a function named square_it in the Environment panel (located at the top right of Rstudio interface). Now, we can use this function as any other base R functions. We type out the name of the function, and inside the parentheses we provide a numeric value x:\n\nsquare_it(5)\n\n[1] 25\n\n\nPretty simple, right? In this case, we only had one line of code that was run, but in theory you could have many lines of code to get obtain the final results that you want to “return” to the user.\n\n\nIn the example above, we created a new variable called square inside the function, and then return the value of square. If you don’t use return(), by default R will return the value of the last line of code inside that function. That is to say, the following function will also work.\n\nsquare_it &lt;- function(x) {\n   x * x\n}\n\nHowever, we recommend always using return at the end of a function as the best practice.\n\nWe have only scratched the surface here when it comes to creating functions! We will revisit this in later lessons, but if interested you can also find more detailed information on this R-bloggers site, which is where we adapted this example from.\nExercise\n\n\n\n\n\n\nBasic\n\n\n\n\nLet’s create a function temp_conv(), which converts the temperature in Fahrenheit (input) to the temperature in Kelvin (output).\n\nWe could perform a two-step calculation: first convert from Fahrenheit to Celsius, and then convert from Celsius to Kelvin.\nThe formula for these two calculations are as follows: temp_c = (temp_f - 32) * 5 / 9; temp_k = temp_c + 273.15. To test your function,\nif your input is 70, the result of temp_conv(70) should be 294.2611.\n\nNow we want to round the temperature in Kelvin (output of temp_conv()) to a single decimal place. Use the round() function with the newly-created temp_conv() function to achieve this in one line of code. If your input is 70, the output should now be 294.3.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Basic\n\n# 1\ntemp_conv &lt;- function(temp_f) {\n  temp_c = (temp_f - 32) * 5 / 9\n  temp_k = temp_c + 273.15\n  return (temp_k)\n}\n\n# 2\nround(temp_conv(70), digits = 1)\n\n[1] 294.3\n\n\n\n\n\n\n\n\n\n\n\nAdvanced\n\n\n\nThe Fibonacci sequence is \\(0, 1, 1, 2, 3, 5, 8, ...\\) where the first two terms are 0 and 1, and for all other terms \\(n^{th}\\) term is the sum of the \\((n-1)^{th}\\) and \\((n-2)^{th}\\) terms. Note that for n=0 you should return 0 and for n=1 you should return 1 as the first 2 terms.\n\nWrite a function fibonacci which takes in a single integer argument n and returns the \\(n^{th}\\) term in the Fibonacci sequence.\nHave your function stop with an appropriate message if the argument n is not an integer. Stop allows you to create your own errors in R. This StackOverflow thread contains useful information on how to tell if something is or is not an integer in R.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Advanced\nfibonacci &lt;- function(n){\n  \n  # These next 3 lines are part 2\n  if((n %% 1)!=0){\n    stop(\"Must provide an integer to fibonacci\")\n  }\n  fibs &lt;- c(0,1)\n  for (i in 2:n){\n    fibs &lt;- c(fibs, fibs[i-1]+fibs[i])\n  }\n  return(fibs[n+1])\n}\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nRe-write your fibonacci function so that it calculates the Fibonacci sequence recursively, meaning that it calls itself. Your function should contain no loops or iterative code.\nYou will need to define two base cases, where the function does not call itself.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n#Challenge\nfibonacci2 &lt;- function(n){\n  if((n %% 1)!=0){\n    stop(\"Must provide an integer to fibonacci\")\n  }\n  # We call these two if statement the 'base cases' of the recursion\n  if (n==0){\n    return(0)\n  }\n  if (n==1){\n    return(1)\n  }\n  # And this is the recursive case, where the function calls itself\n  return(fibonacci2(n-1)+fibonacci2(n-2))\n}\n\nRecursion isn’t relevant to most data analysis, as it is often significantly slower than a non-recursive solution in most programming languages.\nHowever, setting up a solution as recursive sometimes allows us to perform an algorithmic strategy called dynamic programming and is fundamental to most sequence alignment algorithms."
  },
  {
    "objectID": "session-materials/session2/session2.html#for-loops",
    "href": "session-materials/session2/session2.html#for-loops",
    "title": "Session 2: Functions and Data Wrangling",
    "section": "For Loops",
    "text": "For Loops\nLoops are a fundamental structure for repetition in programming. for loops perform the same action for each item in a list of things. The basic syntax is:\n\nfor (item in list_of_items) {\n  do_something(item)\n}\n\nWe can create a vector on the fly to loop a particular number of times:\n\nfor (i in 1:5){\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\nOr use a pre-existing vector or list.\n\nvolumes = c(1.6, 3, 8)\nfor (volume in volumes){\n  mass &lt;- 2.65 * volume ^ 0.9\n  print(mass)\n}\n\n[1] 4.045329\n[1] 7.12287\n[1] 17.21975\n\n\nWe also might want to loop over indices so we can access multiple vectors.\n\nas &lt;- c(2.65, 1.28, 3.29)\nbs &lt;- c(0.9, 1.1, 1.2)\nvolumes = c(1.6, 3, 8)\nmasses &lt;- vector(mode=\"numeric\", length=length(volumes))\nfor (i in 1:length(volumes)){\n   mass &lt;- as[i] * volumes[i] ^ bs[i]\n   masses[i] &lt;- mass\n}\nmasses\n\n[1]  4.045329  4.285913 39.893660\n\n\nWe can use functions inside loops. For example, let’s take a function that returns an estimated mass if the volume &gt; 5 and NA if it’s not.\n\nest_mass &lt;- function(volume, a, b){\n  if (volume &gt; 5) {\n    mass &lt;- a * volume ^ b\n  } else {\n    mass &lt;- NA\n  }\n  return(mass)\n}\n\nWe can then call the function to populate a vector item by item.\n\nmasses &lt;- vector(mode=\"numeric\", length=length(volumes))\nfor (i in 1:length(volumes)){\n   mass &lt;- est_mass(volumes[i], as[i], bs[i])\n   masses[i] &lt;- mass\n}\nmasses\n\n[1]       NA       NA 39.89366\n\n\nTo note, this is the for loop equivalent of an mapply statement.\n\nmasses_apply &lt;- mapply(est_mass, volumes, as, bs)\nmasses_apply\n\n[1]       NA       NA 39.89366\n\n\nIn R we often want to use apply statements as opposed to explicitly writing loops."
  },
  {
    "objectID": "session-materials/session2/session2.html#data-manipulation-using-dplyr-and-tidyr",
    "href": "session-materials/session2/session2.html#data-manipulation-using-dplyr-and-tidyr",
    "title": "Session 2: Functions and Data Wrangling",
    "section": "Data manipulation using dplyr and tidyr",
    "text": "Data manipulation using dplyr and tidyr\nBracket subsetting is handy, but it can be cumbersome and difficult to read, especially for complicated operations.\nSome packages can greatly facilitate our task when we manipulate data. Packages in R are basically sets of additional functions that let you do more stuff. The functions we’ve been using so far, like str() or data.frame(), come built into R; Loading packages can give you access to other specific functions. Before you use a package for the first time you need to install it on your machine, and then you should import it in every subsequent R session when you need it.\n\nThe package dplyr provides powerful tools for data manipulation tasks. It is built to work directly with data frames, with many manipulation tasks optimised.\nAs we will see latter on, sometimes we want a data frame to be reshaped to be able to do some specific analyses or for visualisation. The package tidyr addresses this common problem of reshaping data and provides tools for manipulating data in a tidy way.\n\nTo learn more about dplyr and tidyr after the workshop, you may want to check out this handy data transformation with dplyr cheatsheet and this one about tidyr.\n\nThe tidyverse package is an “umbrella-package” that installs several useful packages for data analysis which work well together, such as tidyr, dplyr, ggplot2, tibble, etc. These packages help us to work and interact with the data. They allow us to do many things with your data, such as subsetting, transforming, visualising, etc.\n\nIf you did the set up, you should have already installed the tidyverse package. Check to see if you have it by trying to load in from the library:\n\n## load the tidyverse packages, incl. dplyr\nlibrary(\"tidyverse\")\n\nIf you got an error message there is no package called ‘tidyverse’ then you have not installed the package yet for this version of R. To install the tidyverse package type:\n\nBiocManager::install(\"tidyverse\")\n\nIf you had to install the tidyverse package, do not forget to load it in this R session by using the library() command above!"
  },
  {
    "objectID": "session-materials/session2/session2.html#loading-data-with-tidyverse",
    "href": "session-materials/session2/session2.html#loading-data-with-tidyverse",
    "title": "Session 2: Functions and Data Wrangling",
    "section": "Loading data with tidyverse",
    "text": "Loading data with tidyverse\nInstead of read.csv(), we will read in our data using the read_csv() function (notice the _ instead of the .), from the tidyverse package readr.\n\nrna &lt;- read_csv(\"data/rnaseq.csv\")\n\n## view the data\nrna\n\n# A tibble: 32,428 × 19\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…       1170 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 Apod    GSM254…      36194 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 3 Cyp2d22 GSM254…       4060 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 4 Klk6    GSM254…        287 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 5 Fcrls   GSM254…         85 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 6 Slc2a4  GSM254…        782 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 7 Exd2    GSM254…       1619 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 Gjc2    GSM254…        288 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 9 Plp1    GSM254…      43217 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n10 Gnb4    GSM254…       1071 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nNotice that the class of the data is now referred to as a “tibble”.\nTibbles tweak some of the behaviors of the data frame objects we introduced in the previously. The data structure is very similar to a data frame. For our purposes the only differences are that:\n\nIt displays the data type of each column under its name. Note that &lt;dbl&gt; is a data type defined to hold numeric values with decimal points.\nIt only prints the first few rows of data and only as many columns as fit on one screen.\n\nWe are now going to learn some of the most common dplyr functions:\n\nselect(): subset columns\nfilter(): subset rows on conditions\nmutate(): create new columns by using information from other columns\ngroup_by() and summarise(): create summary statistics on grouped data\narrange(): sort results\ncount(): count discrete values"
  },
  {
    "objectID": "session-materials/session2/session2.html#selecting-columns-and-filtering-rows",
    "href": "session-materials/session2/session2.html#selecting-columns-and-filtering-rows",
    "title": "Session 2: Functions and Data Wrangling",
    "section": "Selecting columns and filtering rows",
    "text": "Selecting columns and filtering rows\nTo select columns of a data frame, use select(). The first argument to this function is the data frame (rna), and the subsequent arguments are the columns to keep.\n\nselect(rna, gene, sample, tissue, expression)\n\n# A tibble: 32,428 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545336 Cerebellum       1170\n 2 Apod    GSM2545336 Cerebellum      36194\n 3 Cyp2d22 GSM2545336 Cerebellum       4060\n 4 Klk6    GSM2545336 Cerebellum        287\n 5 Fcrls   GSM2545336 Cerebellum         85\n 6 Slc2a4  GSM2545336 Cerebellum        782\n 7 Exd2    GSM2545336 Cerebellum       1619\n 8 Gjc2    GSM2545336 Cerebellum        288\n 9 Plp1    GSM2545336 Cerebellum      43217\n10 Gnb4    GSM2545336 Cerebellum       1071\n# ℹ 32,418 more rows\n\n\nTo select all columns except certain ones, put a “-” in front of the variable to exclude it.\n\nselect(rna, -tissue, -organism)\n\n# A tibble: 32,428 × 17\n   gene    sample   expression   age sex   infection strain  time mouse ENTREZID\n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 Asl     GSM2545…       1170     8 Fema… Influenz… C57BL…     8    14   109900\n 2 Apod    GSM2545…      36194     8 Fema… Influenz… C57BL…     8    14    11815\n 3 Cyp2d22 GSM2545…       4060     8 Fema… Influenz… C57BL…     8    14    56448\n 4 Klk6    GSM2545…        287     8 Fema… Influenz… C57BL…     8    14    19144\n 5 Fcrls   GSM2545…         85     8 Fema… Influenz… C57BL…     8    14    80891\n 6 Slc2a4  GSM2545…        782     8 Fema… Influenz… C57BL…     8    14    20528\n 7 Exd2    GSM2545…       1619     8 Fema… Influenz… C57BL…     8    14    97827\n 8 Gjc2    GSM2545…        288     8 Fema… Influenz… C57BL…     8    14   118454\n 9 Plp1    GSM2545…      43217     8 Fema… Influenz… C57BL…     8    14    18823\n10 Gnb4    GSM2545…       1071     8 Fema… Influenz… C57BL…     8    14    14696\n# ℹ 32,418 more rows\n# ℹ 7 more variables: product &lt;chr&gt;, ensembl_gene_id &lt;chr&gt;,\n#   external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;, gene_biotype &lt;chr&gt;,\n#   phenotype_description &lt;chr&gt;, hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nThis will select all the variables in rna except tissue and organism.\nTo choose rows based on a specific criteria, use filter():\n\nfilter(rna, sex == \"Male\")\n\n# A tibble: 14,740 × 19\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…        626 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 2 Apod    GSM254…      13021 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 3 Cyp2d22 GSM254…       2171 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 4 Klk6    GSM254…        448 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 5 Fcrls   GSM254…        180 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 6 Slc2a4  GSM254…        313 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 7 Exd2    GSM254…       2366 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 8 Gjc2    GSM254…        310 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 9 Plp1    GSM254…      53126 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n10 Gnb4    GSM254…       1355 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n# ℹ 14,730 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\nfilter(rna, sex == \"Male\" & infection == \"NonInfected\")\n\n# A tibble: 4,422 × 19\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…        535 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 2 Apod    GSM254…      13668 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 3 Cyp2d22 GSM254…       2008 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 4 Klk6    GSM254…       1101 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 5 Fcrls   GSM254…        375 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 6 Slc2a4  GSM254…        249 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 7 Exd2    GSM254…       3126 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 8 Gjc2    GSM254…        791 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 9 Plp1    GSM254…      98658 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n10 Gnb4    GSM254…       2437 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n# ℹ 4,412 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nNow let’s imagine we are interested in the human homologs of the mouse genes analysed in this dataset. This information can be found in the last column of the rna tibble, named hsapiens_homolog_associated_gene_name. To visualise it easily, we will create a new table containing just the 2 columns gene and hsapiens_homolog_associated_gene_name.\n\ngenes &lt;- select(rna, gene, hsapiens_homolog_associated_gene_name)\ngenes\n\n# A tibble: 32,428 × 2\n   gene    hsapiens_homolog_associated_gene_name\n   &lt;chr&gt;   &lt;chr&gt;                                \n 1 Asl     ASL                                  \n 2 Apod    APOD                                 \n 3 Cyp2d22 CYP2D6                               \n 4 Klk6    KLK6                                 \n 5 Fcrls   FCRL2                                \n 6 Slc2a4  SLC2A4                               \n 7 Exd2    EXD2                                 \n 8 Gjc2    GJC2                                 \n 9 Plp1    PLP1                                 \n10 Gnb4    GNB4                                 \n# ℹ 32,418 more rows\n\n\nSome mouse genes have no human homologs. These can be retrieved using filter() and the is.na() function, that determines whether something is an NA.\n\nfilter(genes, is.na(hsapiens_homolog_associated_gene_name))\n\n# A tibble: 4,290 × 2\n   gene     hsapiens_homolog_associated_gene_name\n   &lt;chr&gt;    &lt;chr&gt;                                \n 1 Prodh    &lt;NA&gt;                                 \n 2 Tssk5    &lt;NA&gt;                                 \n 3 Vmn2r1   &lt;NA&gt;                                 \n 4 Gm10654  &lt;NA&gt;                                 \n 5 Hexa     &lt;NA&gt;                                 \n 6 Sult1a1  &lt;NA&gt;                                 \n 7 Gm6277   &lt;NA&gt;                                 \n 8 Tmem198b &lt;NA&gt;                                 \n 9 Adam1a   &lt;NA&gt;                                 \n10 Ebp      &lt;NA&gt;                                 \n# ℹ 4,280 more rows\n\n\nIf we want to keep only mouse genes that have a human homolog, we can insert a “!” symbol that negates the result, so we’re asking for every row where hsapiens_homolog_associated_gene_name is not an NA.\n\nfilter(genes, !is.na(hsapiens_homolog_associated_gene_name))\n\n# A tibble: 28,138 × 2\n   gene    hsapiens_homolog_associated_gene_name\n   &lt;chr&gt;   &lt;chr&gt;                                \n 1 Asl     ASL                                  \n 2 Apod    APOD                                 \n 3 Cyp2d22 CYP2D6                               \n 4 Klk6    KLK6                                 \n 5 Fcrls   FCRL2                                \n 6 Slc2a4  SLC2A4                               \n 7 Exd2    EXD2                                 \n 8 Gjc2    GJC2                                 \n 9 Plp1    PLP1                                 \n10 Gnb4    GNB4                                 \n# ℹ 28,128 more rows"
  },
  {
    "objectID": "session-materials/session2/session2.html#pipes",
    "href": "session-materials/session2/session2.html#pipes",
    "title": "Session 2: Functions and Data Wrangling",
    "section": "Pipes",
    "text": "Pipes\nWhat if you want to select and filter at the same time? There are three ways to do this: use intermediate steps, nested functions, or pipes.\nWith intermediate steps, you create a temporary data frame and use that as input to the next function, like this:\n\nrna2 &lt;- filter(rna, sex == \"Male\")\nrna3 &lt;- select(rna2, gene, sample, tissue, expression)\nrna3\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\nThis is readable, but can clutter up your workspace with lots of intermediate objects that you have to name individually. With multiple steps, that can be hard to keep track of.\nYou can also nest functions (i.e. one function inside of another), like this:\n\nrna3 &lt;- select(filter(rna, sex == \"Male\"), gene, sample, tissue, expression)\nrna3\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\nThis is handy, but can be difficult to read if too many functions are nested, as R evaluates the expression from the inside out (in this case, filtering, then selecting).\nThe last option, pipes, are a recent addition to R. Pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same dataset.\nPipes in R look like %&gt;% (made available via the magrittr package) or |&gt; (through base R). If you use RStudio, you can type the pipe with Ctrl + Shift + M if you have a PC or Cmd + Shift + M if you have a Mac.\nIn the above code, we use the pipe to send the rna dataset first through filter() to keep rows where sex is Male, then through select() to keep only the gene, sample, tissue, and expressioncolumns.\nThe pipe %&gt;% takes the object on its left and passes it directly as the first argument to the function on its right, we don’t need to explicitly include the data frame as an argument to the filter() and select() functions any more.\n\nrna %&gt;%\n  filter(sex == \"Male\") %&gt;%\n  select(gene, sample, tissue, expression)\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\nSome may find it helpful to read the pipe like the word “then”. For instance, in the above example, we took the data frame rna, then we filtered for rows with sex == \"Male\", then we selected columns gene, sample, tissue, and expression.\nThe dplyr functions by themselves are somewhat simple, but by combining them into linear workflows with the pipe, we can accomplish more complex manipulations of data frames.\nIf we want to create a new object with this smaller version of the data, we can assign it a new name:\n\nrna3 &lt;- rna %&gt;%\n  filter(sex == \"Male\") %&gt;%\n  select(gene, sample, tissue, expression)\n\nrna3\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\n\n\n\n\n\n\nChallenge:\n\n\n\nUsing pipes, subset the rna data to keep observations in female mice at time 0, where the gene has an expression higher than 50000, and retain only the columns gene, sample, time, expression and age.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrna %&gt;%\n  filter(expression &gt; 50000,\n         sex == \"Female\",\n         time == 0 ) %&gt;%\n  select(gene, sample, time, expression, age)\n\n# A tibble: 9 × 5\n  gene   sample      time expression   age\n  &lt;chr&gt;  &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n1 Plp1   GSM2545337     0     101241     8\n2 Atp1b1 GSM2545337     0      53260     8\n3 Plp1   GSM2545338     0      96534     8\n4 Atp1b1 GSM2545338     0      50614     8\n5 Plp1   GSM2545348     0     102790     8\n6 Atp1b1 GSM2545348     0      59544     8\n7 Plp1   GSM2545353     0      71237     8\n8 Glul   GSM2545353     0      52451     8\n9 Atp1b1 GSM2545353     0      61451     8"
  },
  {
    "objectID": "session-materials/session2/session2.html#mutate",
    "href": "session-materials/session2/session2.html#mutate",
    "title": "Session 2: Functions and Data Wrangling",
    "section": "Mutate",
    "text": "Mutate\nFrequently you’ll want to create new columns based on the values of existing columns, for example to do unit conversions, or to find the ratio of values in two columns. For this we’ll use mutate().\nTo create a new column of time in hours:\n\nrna %&gt;%\n  mutate(time_hours = time * 24) %&gt;%\n  select(time, time_hours)\n\n# A tibble: 32,428 × 2\n    time time_hours\n   &lt;dbl&gt;      &lt;dbl&gt;\n 1     8        192\n 2     8        192\n 3     8        192\n 4     8        192\n 5     8        192\n 6     8        192\n 7     8        192\n 8     8        192\n 9     8        192\n10     8        192\n# ℹ 32,418 more rows\n\n\nYou can also create a second new column based on the first new column within the same call of mutate():\n\nrna %&gt;%\n  mutate(time_hours = time * 24,\n         time_mn = time_hours * 60) %&gt;%\n  select(time, time_hours, time_mn)\n\n# A tibble: 32,428 × 3\n    time time_hours time_mn\n   &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt;\n 1     8        192   11520\n 2     8        192   11520\n 3     8        192   11520\n 4     8        192   11520\n 5     8        192   11520\n 6     8        192   11520\n 7     8        192   11520\n 8     8        192   11520\n 9     8        192   11520\n10     8        192   11520\n# ℹ 32,418 more rows\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nCreate a new data frame from the rna data that meets the following criteria: contains only the gene, chromosome_name, phenotype_description, sample, and expression columns. The expression values should be log-transformed. This data frame must only contain genes located on sex chromosomes, associated with a phenotype_description, and with a log expression higher than 5.\nHint: think about how the commands should be ordered to produce this data frame!\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrna %&gt;%\n  mutate(expression = log(expression)) %&gt;%\n  select(gene, chromosome_name, phenotype_description, sample, expression) %&gt;%\n  filter(chromosome_name == \"X\" | chromosome_name == \"Y\") %&gt;%\n  filter(!is.na(phenotype_description)) %&gt;%\n  filter(expression &gt; 5)\n\n# A tibble: 649 × 5\n   gene   chromosome_name phenotype_description                sample expression\n   &lt;chr&gt;  &lt;chr&gt;           &lt;chr&gt;                                &lt;chr&gt;       &lt;dbl&gt;\n 1 Plp1   X               abnormal CNS glial cell morphology   GSM25…      10.7 \n 2 Slc7a3 X               decreased body length                GSM25…       5.46\n 3 Plxnb3 X               abnormal coat appearance             GSM25…       6.58\n 4 Rbm3   X               abnormal liver morphology            GSM25…       9.32\n 5 Cfp    X               abnormal cardiovascular system phys… GSM25…       6.18\n 6 Ebp    X               abnormal embryonic erythrocyte morp… GSM25…       6.68\n 7 Cd99l2 X               abnormal cellular extravasation      GSM25…       8.04\n 8 Piga   X               abnormal brain development           GSM25…       6.06\n 9 Pim2   X               decreased T cell proliferation       GSM25…       7.11\n10 Itm2a  X               no abnormal phenotype detected       GSM25…       7.48\n# ℹ 639 more rows"
  },
  {
    "objectID": "session-materials/session2/session2.html#split-apply-combine-data-analysis",
    "href": "session-materials/session2/session2.html#split-apply-combine-data-analysis",
    "title": "Session 2: Functions and Data Wrangling",
    "section": "Split-apply-combine data analysis",
    "text": "Split-apply-combine data analysis\nMany data analysis tasks can be approached using the split-apply-combine paradigm: split the data into groups, apply some analysis to each group, and then combine the results. dplyr makes this very easy through the use of the group_by() function.\n\nrna %&gt;%\n  group_by(gene)\n\n# A tibble: 32,428 × 19\n# Groups:   gene [1,474]\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…       1170 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 Apod    GSM254…      36194 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 3 Cyp2d22 GSM254…       4060 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 4 Klk6    GSM254…        287 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 5 Fcrls   GSM254…         85 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 6 Slc2a4  GSM254…        782 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 7 Exd2    GSM254…       1619 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 Gjc2    GSM254…        288 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 9 Plp1    GSM254…      43217 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n10 Gnb4    GSM254…       1071 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nThe group_by() function doesn’t perform any data processing, it groups the data into subsets: in the example above, our initial tibble of 32428 observations is split into 1474 groups based on the gene variable.\nWe could similarly decide to group the tibble by the samples:\n\nrna %&gt;%\n  group_by(sample)\n\n# A tibble: 32,428 × 19\n# Groups:   sample [22]\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…       1170 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 Apod    GSM254…      36194 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 3 Cyp2d22 GSM254…       4060 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 4 Klk6    GSM254…        287 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 5 Fcrls   GSM254…         85 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 6 Slc2a4  GSM254…        782 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 7 Exd2    GSM254…       1619 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 Gjc2    GSM254…        288 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 9 Plp1    GSM254…      43217 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n10 Gnb4    GSM254…       1071 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nHere our initial tibble of 32428 observations is split into 22 groups based on the sample variable.\nOnce the data has been grouped, subsequent operations will be applied on each group independently.\n\nThe summarise() function\ngroup_by() is often used together with summarise(), which collapses each group into a single-row summary of that group.\ngroup_by() takes as arguments the column names that contain the categorical variables for which you want to calculate the summary statistics. So to compute the mean expression by gene:\n\nrna %&gt;%\n  group_by(gene) %&gt;%\n  summarise(mean_expression = mean(expression))\n\n# A tibble: 1,474 × 2\n   gene     mean_expression\n   &lt;chr&gt;              &lt;dbl&gt;\n 1 AI504432         1053.  \n 2 AW046200          131.  \n 3 AW551984          295.  \n 4 Aamp             4751.  \n 5 Abca12              4.55\n 6 Abcc8            2498.  \n 7 Abhd14a           525.  \n 8 Abi2             4909.  \n 9 Abi3bp           1002.  \n10 Abl2             2124.  \n# ℹ 1,464 more rows\n\n\nWe could also want to calculate the mean expression levels of all genes in each sample:\n\nrna %&gt;%\n  group_by(sample) %&gt;%\n  summarise(mean_expression = mean(expression))\n\n# A tibble: 22 × 2\n   sample     mean_expression\n   &lt;chr&gt;                &lt;dbl&gt;\n 1 GSM2545336           2062.\n 2 GSM2545337           1766.\n 3 GSM2545338           1668.\n 4 GSM2545339           1696.\n 5 GSM2545340           1682.\n 6 GSM2545341           1638.\n 7 GSM2545342           1594.\n 8 GSM2545343           2107.\n 9 GSM2545344           1712.\n10 GSM2545345           1700.\n# ℹ 12 more rows\n\n\nBut we can can also group by multiple columns:\n\nrna %&gt;%\n  group_by(gene, infection, time) %&gt;%\n  summarise(mean_expression = mean(expression))\n\n`summarise()` has grouped output by 'gene', 'infection'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 4,422 × 4\n# Groups:   gene, infection [2,948]\n   gene     infection    time mean_expression\n   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;           &lt;dbl&gt;\n 1 AI504432 InfluenzaA      4           1104.\n 2 AI504432 InfluenzaA      8           1014 \n 3 AI504432 NonInfected     0           1034.\n 4 AW046200 InfluenzaA      4            152.\n 5 AW046200 InfluenzaA      8             81 \n 6 AW046200 NonInfected     0            155.\n 7 AW551984 InfluenzaA      4            302.\n 8 AW551984 InfluenzaA      8            342.\n 9 AW551984 NonInfected     0            238 \n10 Aamp     InfluenzaA      4           4870 \n# ℹ 4,412 more rows\n\n\nOnce the data is grouped, you can also summarise multiple variables at the same time (and not necessarily on the same variable). For instance, we could add a column indicating the median expression by gene and by condition:\n\nrna %&gt;%\n  group_by(gene, infection, time) %&gt;%\n  summarise(mean_expression = mean(expression),\n            median_expression = median(expression))\n\n`summarise()` has grouped output by 'gene', 'infection'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 4,422 × 5\n# Groups:   gene, infection [2,948]\n   gene     infection    time mean_expression median_expression\n   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;           &lt;dbl&gt;             &lt;dbl&gt;\n 1 AI504432 InfluenzaA      4           1104.             1094.\n 2 AI504432 InfluenzaA      8           1014               985 \n 3 AI504432 NonInfected     0           1034.             1016 \n 4 AW046200 InfluenzaA      4            152.              144.\n 5 AW046200 InfluenzaA      8             81                82 \n 6 AW046200 NonInfected     0            155.              163 \n 7 AW551984 InfluenzaA      4            302.              245 \n 8 AW551984 InfluenzaA      8            342.              287 \n 9 AW551984 NonInfected     0            238               265 \n10 Aamp     InfluenzaA      4           4870              4708 \n# ℹ 4,412 more rows\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nCalculate the mean expression level of gene “Dok3” by timepoints.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrna %&gt;%\n  filter(gene == \"Dok3\") %&gt;%\n  group_by(time) %&gt;%\n  summarise(mean = mean(expression))\n\n# A tibble: 3 × 2\n   time  mean\n  &lt;dbl&gt; &lt;dbl&gt;\n1     0  169 \n2     4  156.\n3     8   61 \n\n\n\n\n\n\n\nCounting\nWhen working with data, we often want to know the number of observations found for each factor or combination of factors. For this task, dplyr provides count(). For example, if we wanted to count the number of rows of data for each infected and non-infected samples, we would do:\n\nrna %&gt;%\n    count(infection)\n\n# A tibble: 2 × 2\n  infection       n\n  &lt;chr&gt;       &lt;int&gt;\n1 InfluenzaA  22110\n2 NonInfected 10318\n\n\nThe count() function is shorthand for something we’ve already seen: grouping by a variable, and summarising it by counting the number of observations in that group. In other words, rna %&gt;% count(infection) is equivalent to:\n\nrna %&gt;%\n    group_by(infection) %&gt;%\n    summarise(n = n())\n\n# A tibble: 2 × 2\n  infection       n\n  &lt;chr&gt;       &lt;int&gt;\n1 InfluenzaA  22110\n2 NonInfected 10318\n\n\nThe previous example shows the use of count() to count the number of rows/observations for one factor (i.e., infection). If we wanted to count a combination of factors, such as infection and time, we would specify the first and the second factor as the arguments of count():\n\nrna %&gt;%\n    count(infection, time)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      4 11792\n2 InfluenzaA      8 10318\n3 NonInfected     0 10318\n\n\nwhich is equivalent to this:\n\nrna %&gt;%\n  group_by(infection, time) %&gt;%\n  summarise(n = n())\n\n`summarise()` has grouped output by 'infection'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 3 × 3\n# Groups:   infection [2]\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      4 11792\n2 InfluenzaA      8 10318\n3 NonInfected     0 10318\n\n\nIt is sometimes useful to sort the result to facilitate the comparisons. We can use arrange() to sort the table. For instance, we might want to arrange the table above by time:\n\nrna %&gt;%\n  count(infection, time) %&gt;%\n  arrange(time)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 NonInfected     0 10318\n2 InfluenzaA      4 11792\n3 InfluenzaA      8 10318\n\n\nor by counts:\n\nrna %&gt;%\n  count(infection, time) %&gt;%\n  arrange(n)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      8 10318\n2 NonInfected     0 10318\n3 InfluenzaA      4 11792\n\n\nTo sort in descending order, we need to add the desc() function:\n\nrna %&gt;%\n  count(infection, time) %&gt;%\n  arrange(desc(n))\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      4 11792\n2 InfluenzaA      8 10318\n3 NonInfected     0 10318\n\n\n\n\n\n\n\n\nChallenge\n\n\n\n\nHow many genes were analysed in each sample?\nUse group_by() and summarise() to evaluate the sequencing depth (the sum of all counts) in each sample. Which sample has the highest sequencing depth?\nPick one sample and evaluate the number of genes by biotype.\nIdentify genes associated with the “abnormal DNA methylation” phenotype description, and calculate their mean expression (in log) at time 0, time 4 and time 8.\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n## 1.\nrna %&gt;%\n  count(sample)\n\n# A tibble: 22 × 2\n   sample         n\n   &lt;chr&gt;      &lt;int&gt;\n 1 GSM2545336  1474\n 2 GSM2545337  1474\n 3 GSM2545338  1474\n 4 GSM2545339  1474\n 5 GSM2545340  1474\n 6 GSM2545341  1474\n 7 GSM2545342  1474\n 8 GSM2545343  1474\n 9 GSM2545344  1474\n10 GSM2545345  1474\n# ℹ 12 more rows\n\n## 2.\nrna %&gt;%\n  group_by(sample) %&gt;%\n  summarise(seq_depth = sum(expression)) %&gt;%\n  arrange(desc(seq_depth))\n\n# A tibble: 22 × 2\n   sample     seq_depth\n   &lt;chr&gt;          &lt;dbl&gt;\n 1 GSM2545350   3255566\n 2 GSM2545352   3216163\n 3 GSM2545343   3105652\n 4 GSM2545336   3039671\n 5 GSM2545380   3036098\n 6 GSM2545353   2953249\n 7 GSM2545348   2913678\n 8 GSM2545362   2913517\n 9 GSM2545351   2782464\n10 GSM2545349   2758006\n# ℹ 12 more rows\n\n## 3.\nrna %&gt;%\n  filter(sample == \"GSM2545336\") %&gt;%\n  group_by(gene_biotype) %&gt;%\n  count(gene_biotype) %&gt;%\n  arrange(desc(n))\n\n# A tibble: 13 × 2\n# Groups:   gene_biotype [13]\n   gene_biotype                           n\n   &lt;chr&gt;                              &lt;int&gt;\n 1 protein_coding                      1321\n 2 lncRNA                                69\n 3 processed_pseudogene                  59\n 4 miRNA                                  7\n 5 snoRNA                                 5\n 6 TEC                                    4\n 7 polymorphic_pseudogene                 2\n 8 unprocessed_pseudogene                 2\n 9 IG_C_gene                              1\n10 scaRNA                                 1\n11 transcribed_processed_pseudogene       1\n12 transcribed_unitary_pseudogene         1\n13 transcribed_unprocessed_pseudogene     1\n\n## 4.\nrna %&gt;%\n  filter(phenotype_description == \"abnormal DNA methylation\") %&gt;%\n  group_by(gene, time) %&gt;%\n  summarise(mean_expression = mean(log(expression))) %&gt;%\n  arrange()\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 6 × 3\n# Groups:   gene [2]\n  gene   time mean_expression\n  &lt;chr&gt; &lt;dbl&gt;           &lt;dbl&gt;\n1 Xist      0            6.95\n2 Xist      4            6.34\n3 Xist      8            7.13\n4 Zdbf2     0            6.27\n5 Zdbf2     4            6.27\n6 Zdbf2     8            6.19"
  },
  {
    "objectID": "session-materials/session2/session2.html#reshaping-data",
    "href": "session-materials/session2/session2.html#reshaping-data",
    "title": "Session 2: Functions and Data Wrangling",
    "section": "Reshaping data",
    "text": "Reshaping data\nIn the rna tibble, the rows contain expression values (the unit) that are associated with a combination of 2 other variables: gene and sample.\nAll the other columns correspond to variables describing either the sample (organism, age, sex, …) or the gene (gene_biotype, ENTREZ_ID, product, …). The variables that don’t change with genes or with samples will have the same value in all the rows.\n\nrna %&gt;%\n  arrange(gene)\n\n# A tibble: 32,428 × 19\n   gene     sample expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 AI504432 GSM25…       1230 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 AI504432 GSM25…       1085 Mus mus…     8 Fema… NonInfec… C57BL…     0 Cereb…\n 3 AI504432 GSM25…        969 Mus mus…     8 Fema… NonInfec… C57BL…     0 Cereb…\n 4 AI504432 GSM25…       1284 Mus mus…     8 Fema… Influenz… C57BL…     4 Cereb…\n 5 AI504432 GSM25…        966 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 6 AI504432 GSM25…        918 Mus mus…     8 Male  Influenz… C57BL…     8 Cereb…\n 7 AI504432 GSM25…        985 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 AI504432 GSM25…        972 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 9 AI504432 GSM25…       1000 Mus mus…     8 Fema… Influenz… C57BL…     4 Cereb…\n10 AI504432 GSM25…        816 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nThis structure is called a long-format, as one column contains all the values, and other column(s) list(s) the context of the value.\nIn certain cases, the long-format is not really “human-readable”, and another format, a wide-format is preferred, as a more compact way of representing the data. This is typically the case with gene expression values that scientists are used to look as matrices, were rows represent genes and columns represent samples.\nIn this format, it would therefore become straightforward to explore the relationship between the gene expression levels within, and between, the samples.\n\n\n# A tibble: 1,474 × 23\n   gene    GSM2545336 GSM2545337 GSM2545338 GSM2545339 GSM2545340 GSM2545341\n   &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n 1 Asl           1170        361        400        586        626        988\n 2 Apod         36194      10347       9173      10620      13021      29594\n 3 Cyp2d22       4060       1616       1603       1901       2171       3349\n 4 Klk6           287        629        641        578        448        195\n 5 Fcrls           85        233        244        237        180         38\n 6 Slc2a4         782        231        248        265        313        786\n 7 Exd2          1619       2288       2235       2513       2366       1359\n 8 Gjc2           288        595        568        551        310        146\n 9 Plp1         43217     101241      96534      58354      53126      27173\n10 Gnb4          1071       1791       1867       1430       1355        798\n# ℹ 1,464 more rows\n# ℹ 16 more variables: GSM2545342 &lt;dbl&gt;, GSM2545343 &lt;dbl&gt;, GSM2545344 &lt;dbl&gt;,\n#   GSM2545345 &lt;dbl&gt;, GSM2545346 &lt;dbl&gt;, GSM2545347 &lt;dbl&gt;, GSM2545348 &lt;dbl&gt;,\n#   GSM2545349 &lt;dbl&gt;, GSM2545350 &lt;dbl&gt;, GSM2545351 &lt;dbl&gt;, GSM2545352 &lt;dbl&gt;,\n#   GSM2545353 &lt;dbl&gt;, GSM2545354 &lt;dbl&gt;, GSM2545362 &lt;dbl&gt;, GSM2545363 &lt;dbl&gt;,\n#   GSM2545380 &lt;dbl&gt;\n\n\nTo convert the gene expression values from rna into a wide-format, we need to create a new table where the values of the sample column would become the names of column variables.\nThe key point here is that we are still following a tidy data structure, but we have reshaped the data according to the observations of interest: expression levels per gene instead of recording them per gene and per sample.\nThe opposite transformation would be to transform column names into values of a new variable.\nWe can do both these of transformations with two tidyr functions, pivot_longer() and pivot_wider() (see here for details).\n\nPivoting the data into a wider format\nLet’s select the first 3 columns of rna and use pivot_wider() to transform the data into a wide-format.\n\nrna_exp &lt;- rna %&gt;%\n  select(gene, sample, expression)\nrna_exp\n\n# A tibble: 32,428 × 3\n   gene    sample     expression\n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545336       1170\n 2 Apod    GSM2545336      36194\n 3 Cyp2d22 GSM2545336       4060\n 4 Klk6    GSM2545336        287\n 5 Fcrls   GSM2545336         85\n 6 Slc2a4  GSM2545336        782\n 7 Exd2    GSM2545336       1619\n 8 Gjc2    GSM2545336        288\n 9 Plp1    GSM2545336      43217\n10 Gnb4    GSM2545336       1071\n# ℹ 32,418 more rows\n\n\npivot_wider takes three main arguments:\n\nthe data to be transformed;\nthe names_from : the column whose values will become new column names;\nthe values_from: the column whose values will fill the new columns.\n\n\n\n\n\n\nWide pivot of the rna data.\n\n\n\n\n\nrna_wide &lt;- rna_exp %&gt;%\n  pivot_wider(names_from = sample,\n              values_from = expression)\nrna_wide\n\n# A tibble: 1,474 × 23\n   gene    GSM2545336 GSM2545337 GSM2545338 GSM2545339 GSM2545340 GSM2545341\n   &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n 1 Asl           1170        361        400        586        626        988\n 2 Apod         36194      10347       9173      10620      13021      29594\n 3 Cyp2d22       4060       1616       1603       1901       2171       3349\n 4 Klk6           287        629        641        578        448        195\n 5 Fcrls           85        233        244        237        180         38\n 6 Slc2a4         782        231        248        265        313        786\n 7 Exd2          1619       2288       2235       2513       2366       1359\n 8 Gjc2           288        595        568        551        310        146\n 9 Plp1         43217     101241      96534      58354      53126      27173\n10 Gnb4          1071       1791       1867       1430       1355        798\n# ℹ 1,464 more rows\n# ℹ 16 more variables: GSM2545342 &lt;dbl&gt;, GSM2545343 &lt;dbl&gt;, GSM2545344 &lt;dbl&gt;,\n#   GSM2545345 &lt;dbl&gt;, GSM2545346 &lt;dbl&gt;, GSM2545347 &lt;dbl&gt;, GSM2545348 &lt;dbl&gt;,\n#   GSM2545349 &lt;dbl&gt;, GSM2545350 &lt;dbl&gt;, GSM2545351 &lt;dbl&gt;, GSM2545352 &lt;dbl&gt;,\n#   GSM2545353 &lt;dbl&gt;, GSM2545354 &lt;dbl&gt;, GSM2545362 &lt;dbl&gt;, GSM2545363 &lt;dbl&gt;,\n#   GSM2545380 &lt;dbl&gt;\n\n\nNote that by default, the pivot_wider() function will add NA for missing values.\nLet’s imagine that for some reason, we had some missing expression values for some genes in certain samples. In the following fictive example, the gene Cyp2d22 has only one expression value, in GSM2545338 sample.\n\nrna_with_missing_values\n\n# A tibble: 7 × 3\n  gene    sample     expression\n  &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n1 Asl     GSM2545336       1170\n2 Apod    GSM2545336      36194\n3 Asl     GSM2545337        361\n4 Apod    GSM2545337      10347\n5 Asl     GSM2545338        400\n6 Apod    GSM2545338       9173\n7 Cyp2d22 GSM2545338       1603\n\n\nBy default, the pivot_wider() function will add NA for missing values. This can be parameterised with the values_fill argument of the pivot_wider() function.\n\nrna_with_missing_values %&gt;%\n  pivot_wider(names_from = sample,\n              values_from = expression)\n\n# A tibble: 3 × 4\n  gene    GSM2545336 GSM2545337 GSM2545338\n  &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 Asl           1170        361        400\n2 Apod         36194      10347       9173\n3 Cyp2d22         NA         NA       1603\n\nrna_with_missing_values %&gt;%\n  pivot_wider(names_from = sample,\n              values_from = expression,\n              values_fill = 0)\n\n# A tibble: 3 × 4\n  gene    GSM2545336 GSM2545337 GSM2545338\n  &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 Asl           1170        361        400\n2 Apod         36194      10347       9173\n3 Cyp2d22          0          0       1603\n\n\n\n\nPivoting data into a longer format\nIn the opposite situation we are using the column names and turning them into a pair of new variables. One variable represents the column names as values, and the other variable contains the values previously associated with the column names.\npivot_longer() takes four main arguments:\n\nthe data to be transformed;\nthe names_to: the new column name we wish to create and populate with the current column names;\nthe values_to: the new column name we wish to create and populate with current values;\nthe names of the columns to be used to populate the names_to and values_to variables (or to drop).\n\n\n\n\n\n\nLong pivot of the rna data.\n\n\n\n\nTo recreate rna_long from rna_wide we would create a key called sample and value called expression and use all columns except gene for the key variable. Here we drop gene column with a minus sign.\nNotice how the new variable names are to be quoted here.\n\nrna_long &lt;- rna_wide %&gt;%\n    pivot_longer(names_to = \"sample\",\n                 values_to = \"expression\",\n                 -gene)\nrna_long\n\n# A tibble: 32,428 × 3\n   gene  sample     expression\n   &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl   GSM2545336       1170\n 2 Asl   GSM2545337        361\n 3 Asl   GSM2545338        400\n 4 Asl   GSM2545339        586\n 5 Asl   GSM2545340        626\n 6 Asl   GSM2545341        988\n 7 Asl   GSM2545342        836\n 8 Asl   GSM2545343        535\n 9 Asl   GSM2545344        586\n10 Asl   GSM2545345        597\n# ℹ 32,418 more rows\n\n\nWe could also have used a specification for what columns to include. This can be useful if you have a large number of identifying columns, and it’s easier to specify what to gather than what to leave alone. Here the starts_with() function can help to retrieve sample names without having to list them all! Another possibility would be to use the : operator!\n\nrna_wide %&gt;%\n    pivot_longer(names_to = \"sample\",\n                 values_to = \"expression\",\n                 cols = starts_with(\"GSM\"))\n\n# A tibble: 32,428 × 3\n   gene  sample     expression\n   &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl   GSM2545336       1170\n 2 Asl   GSM2545337        361\n 3 Asl   GSM2545338        400\n 4 Asl   GSM2545339        586\n 5 Asl   GSM2545340        626\n 6 Asl   GSM2545341        988\n 7 Asl   GSM2545342        836\n 8 Asl   GSM2545343        535\n 9 Asl   GSM2545344        586\n10 Asl   GSM2545345        597\n# ℹ 32,418 more rows\n\nrna_wide %&gt;%\n    pivot_longer(names_to = \"sample\",\n                 values_to = \"expression\",\n                 GSM2545336:GSM2545380)\n\n# A tibble: 32,428 × 3\n   gene  sample     expression\n   &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl   GSM2545336       1170\n 2 Asl   GSM2545337        361\n 3 Asl   GSM2545338        400\n 4 Asl   GSM2545339        586\n 5 Asl   GSM2545340        626\n 6 Asl   GSM2545341        988\n 7 Asl   GSM2545342        836\n 8 Asl   GSM2545343        535\n 9 Asl   GSM2545344        586\n10 Asl   GSM2545345        597\n# ℹ 32,418 more rows\n\n\nNote that if we had missing values in the wide-format, the NA would be included in the new long format.\nRemember our previous fictive tibble containing missing values:\n\nrna_with_missing_values\n\n# A tibble: 7 × 3\n  gene    sample     expression\n  &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n1 Asl     GSM2545336       1170\n2 Apod    GSM2545336      36194\n3 Asl     GSM2545337        361\n4 Apod    GSM2545337      10347\n5 Asl     GSM2545338        400\n6 Apod    GSM2545338       9173\n7 Cyp2d22 GSM2545338       1603\n\nwide_with_NA &lt;- rna_with_missing_values %&gt;%\n  pivot_wider(names_from = sample,\n              values_from = expression)\nwide_with_NA\n\n# A tibble: 3 × 4\n  gene    GSM2545336 GSM2545337 GSM2545338\n  &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 Asl           1170        361        400\n2 Apod         36194      10347       9173\n3 Cyp2d22         NA         NA       1603\n\nwide_with_NA %&gt;%\n    pivot_longer(names_to = \"sample\",\n                 values_to = \"expression\",\n                 -gene)\n\n# A tibble: 9 × 3\n  gene    sample     expression\n  &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n1 Asl     GSM2545336       1170\n2 Asl     GSM2545337        361\n3 Asl     GSM2545338        400\n4 Apod    GSM2545336      36194\n5 Apod    GSM2545337      10347\n6 Apod    GSM2545338       9173\n7 Cyp2d22 GSM2545336         NA\n8 Cyp2d22 GSM2545337         NA\n9 Cyp2d22 GSM2545338       1603\n\n\nPivoting to wider and longer formats can be a useful way to balance out a dataset so every replicate has the same composition.\n\n\n\n\n\n\nQuestion\n\n\n\nStarting from the rna table, use the pivot_wider() function to create a wide-format table giving the gene expression levels in each mouse. Then use the pivot_longer() function to restore a long-format table.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nrna1 &lt;- rna %&gt;%\nselect(gene, mouse, expression) %&gt;%\npivot_wider(names_from = mouse, values_from = expression)\nrna1\n\n# A tibble: 1,474 × 23\n   gene     `14`    `9`  `10`  `15`  `18`   `6`   `5`  `11`  `22`  `13`  `23`\n   &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 Asl      1170    361   400   586   626   988   836   535   586   597   938\n 2 Apod    36194  10347  9173 10620 13021 29594 24959 13668 13230 15868 27769\n 3 Cyp2d22  4060   1616  1603  1901  2171  3349  3122  2008  2254  2277  2985\n 4 Klk6      287    629   641   578   448   195   186  1101   537   567   327\n 5 Fcrls      85    233   244   237   180    38    68   375   199   177    89\n 6 Slc2a4    782    231   248   265   313   786   528   249   266   357   654\n 7 Exd2     1619   2288  2235  2513  2366  1359  1474  3126  2379  2173  1531\n 8 Gjc2      288    595   568   551   310   146   186   791   454   370   240\n 9 Plp1    43217 101241 96534 58354 53126 27173 28728 98658 61356 61647 38019\n10 Gnb4     1071   1791  1867  1430  1355   798   806  2437  1394  1554   960\n# ℹ 1,464 more rows\n# ℹ 11 more variables: `24` &lt;dbl&gt;, `8` &lt;dbl&gt;, `7` &lt;dbl&gt;, `1` &lt;dbl&gt;, `16` &lt;dbl&gt;,\n#   `21` &lt;dbl&gt;, `4` &lt;dbl&gt;, `2` &lt;dbl&gt;, `20` &lt;dbl&gt;, `12` &lt;dbl&gt;, `19` &lt;dbl&gt;\n\nrna1 %&gt;%\npivot_longer(names_to = \"mouse_id\", values_to = \"counts\", -gene)\n\n# A tibble: 32,428 × 3\n   gene  mouse_id counts\n   &lt;chr&gt; &lt;chr&gt;     &lt;dbl&gt;\n 1 Asl   14         1170\n 2 Asl   9           361\n 3 Asl   10          400\n 4 Asl   15          586\n 5 Asl   18          626\n 6 Asl   6           988\n 7 Asl   5           836\n 8 Asl   11          535\n 9 Asl   22          586\n10 Asl   13          597\n# ℹ 32,418 more rows\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nSubset genes located on X and Y chromosomes from the rna data frame and spread the data frame with sex as columns, chromosome_name as rows, and the mean expression of genes located in each chromosome as the values, as in the following tibble:\n\n\n\n\n\nYou will need to summarise before reshaping!\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nLet’s first calculate the mean expression level of X and Y linked genes from male and female samples…\n\n rna %&gt;%\n  filter(chromosome_name == \"Y\" | chromosome_name == \"X\") %&gt;%\n  group_by(sex, chromosome_name) %&gt;%\n  summarise(mean = mean(expression))\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 4 × 3\n# Groups:   sex [2]\n  sex    chromosome_name  mean\n  &lt;chr&gt;  &lt;chr&gt;           &lt;dbl&gt;\n1 Female X               3504.\n2 Female Y                  3 \n3 Male   X               2497.\n4 Male   Y               2117.\n\n\nAnd pivot the table to wide format\n\nrna_1 &lt;- rna %&gt;%\n  filter(chromosome_name == \"Y\" | chromosome_name == \"X\") %&gt;%\n  group_by(sex, chromosome_name) %&gt;%\n  summarise(mean = mean(expression)) %&gt;%\n  pivot_wider(names_from = sex,\n              values_from = mean)\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\nrna_1\n\n# A tibble: 2 × 3\n  chromosome_name Female  Male\n  &lt;chr&gt;            &lt;dbl&gt; &lt;dbl&gt;\n1 X                3504. 2497.\n2 Y                   3  2117.\n\n\nNow take that data frame and transform it with pivot_longer() so each row is a unique chromosome_name by gender combination.\n\nrna_1 %&gt;%\n  pivot_longer(names_to = \"gender\",\n               values_to = \"mean\",\n               -chromosome_name)\n\n# A tibble: 4 × 3\n  chromosome_name gender  mean\n  &lt;chr&gt;           &lt;chr&gt;  &lt;dbl&gt;\n1 X               Female 3504.\n2 X               Male   2497.\n3 Y               Female    3 \n4 Y               Male   2117.\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nUse the rna dataset to create an expression matrix where each row represents the mean expression levels of genes and columns represent the different timepoints.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nLet’s first calculate the mean expression by gene and by time\n\nrna %&gt;%\n  group_by(gene, time) %&gt;%\n  summarise(mean_exp = mean(expression))\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 4,422 × 3\n# Groups:   gene [1,474]\n   gene      time mean_exp\n   &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n 1 AI504432     0    1034.\n 2 AI504432     4    1104.\n 3 AI504432     8    1014 \n 4 AW046200     0     155.\n 5 AW046200     4     152.\n 6 AW046200     8      81 \n 7 AW551984     0     238 \n 8 AW551984     4     302.\n 9 AW551984     8     342.\n10 Aamp         0    4603.\n# ℹ 4,412 more rows\n\n\nbefore using the pivot_wider() function\n\nrna_time &lt;- rna %&gt;%\n  group_by(gene, time) %&gt;%\n  summarise(mean_exp = mean(expression)) %&gt;%\n  pivot_wider(names_from = time,\n              values_from = mean_exp)\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\nrna_time\n\n# A tibble: 1,474 × 4\n# Groups:   gene [1,474]\n   gene         `0`     `4`     `8`\n   &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 AI504432 1034.   1104.   1014   \n 2 AW046200  155.    152.     81   \n 3 AW551984  238     302.    342.  \n 4 Aamp     4603.   4870    4763.  \n 5 Abca12      5.29    4.25    4.14\n 6 Abcc8    2576.   2609.   2292.  \n 7 Abhd14a   591.    547.    432.  \n 8 Abi2     4881.   4903.   4945.  \n 9 Abi3bp   1175.   1061.    762.  \n10 Abl2     2170.   2078.   2131.  \n# ℹ 1,464 more rows\n\n\nNotice that this generates a tibble with some column names starting by a number. If we wanted to select the column corresponding to the timepoints, we could not use the column names directly… What happens when we select the column 4?\n\nrna %&gt;%\n  group_by(gene, time) %&gt;%\n  summarise(mean_exp = mean(expression)) %&gt;%\n  pivot_wider(names_from = time,\n              values_from = mean_exp) %&gt;%\n  select(gene, 4)\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,474 × 2\n# Groups:   gene [1,474]\n   gene         `8`\n   &lt;chr&gt;      &lt;dbl&gt;\n 1 AI504432 1014   \n 2 AW046200   81   \n 3 AW551984  342.  \n 4 Aamp     4763.  \n 5 Abca12      4.14\n 6 Abcc8    2292.  \n 7 Abhd14a   432.  \n 8 Abi2     4945.  \n 9 Abi3bp    762.  \n10 Abl2     2131.  \n# ℹ 1,464 more rows\n\n\nTo select the timepoint 4, we would have to quote the column name, with backticks “`”\n\nrna %&gt;%\n  group_by(gene, time) %&gt;%\n  summarise(mean_exp = mean(expression)) %&gt;%\n  pivot_wider(names_from = time,\n              values_from = mean_exp) %&gt;%\n  select(gene, `4`)\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,474 × 2\n# Groups:   gene [1,474]\n   gene         `4`\n   &lt;chr&gt;      &lt;dbl&gt;\n 1 AI504432 1104.  \n 2 AW046200  152.  \n 3 AW551984  302.  \n 4 Aamp     4870   \n 5 Abca12      4.25\n 6 Abcc8    2609.  \n 7 Abhd14a   547.  \n 8 Abi2     4903.  \n 9 Abi3bp   1061.  \n10 Abl2     2078.  \n# ℹ 1,464 more rows\n\n\nAnother possibility would be to rename the column, choosing a name that doesn’t start by a number :\n\nrna %&gt;%\n  group_by(gene, time) %&gt;%\n  summarise(mean_exp = mean(expression)) %&gt;%\n  pivot_wider(names_from = time,\n              values_from = mean_exp) %&gt;%\n  rename(\"time0\" = `0`, \"time4\" = `4`, \"time8\" = `8`) %&gt;%\n  select(gene, time4)\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,474 × 2\n# Groups:   gene [1,474]\n   gene       time4\n   &lt;chr&gt;      &lt;dbl&gt;\n 1 AI504432 1104.  \n 2 AW046200  152.  \n 3 AW551984  302.  \n 4 Aamp     4870   \n 5 Abca12      4.25\n 6 Abcc8    2609.  \n 7 Abhd14a   547.  \n 8 Abi2     4903.  \n 9 Abi3bp   1061.  \n10 Abl2     2078.  \n# ℹ 1,464 more rows\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nUse the previous data frame containing mean expression levels per timepoint and create a new column containing fold-changes between timepoint 8 and timepoint 0, and fold-changes between timepoint 8 and timepoint 4. Convert this table into a long-format table gathering the fold-changes calculated.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nStarting from the rna_time tibble:\n\nrna_time\n\n# A tibble: 1,474 × 4\n# Groups:   gene [1,474]\n   gene         `0`     `4`     `8`\n   &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 AI504432 1034.   1104.   1014   \n 2 AW046200  155.    152.     81   \n 3 AW551984  238     302.    342.  \n 4 Aamp     4603.   4870    4763.  \n 5 Abca12      5.29    4.25    4.14\n 6 Abcc8    2576.   2609.   2292.  \n 7 Abhd14a   591.    547.    432.  \n 8 Abi2     4881.   4903.   4945.  \n 9 Abi3bp   1175.   1061.    762.  \n10 Abl2     2170.   2078.   2131.  \n# ℹ 1,464 more rows\n\n\nCalculate fold-changes:\n\nrna_time %&gt;%\n  mutate(time_8_vs_0 = `8` / `0`, time_8_vs_4 = `8` / `4`)\n\n# A tibble: 1,474 × 6\n# Groups:   gene [1,474]\n   gene         `0`     `4`     `8` time_8_vs_0 time_8_vs_4\n   &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 AI504432 1034.   1104.   1014          0.981       0.918\n 2 AW046200  155.    152.     81          0.522       0.532\n 3 AW551984  238     302.    342.         1.44        1.13 \n 4 Aamp     4603.   4870    4763.         1.03        0.978\n 5 Abca12      5.29    4.25    4.14       0.784       0.975\n 6 Abcc8    2576.   2609.   2292.         0.889       0.878\n 7 Abhd14a   591.    547.    432.         0.731       0.791\n 8 Abi2     4881.   4903.   4945.         1.01        1.01 \n 9 Abi3bp   1175.   1061.    762.         0.649       0.719\n10 Abl2     2170.   2078.   2131.         0.982       1.03 \n# ℹ 1,464 more rows\n\n\nAnd use the pivot_longer() function:\n\nrna_time %&gt;%\n  mutate(time_8_vs_0 = `8` / `0`, time_8_vs_4 = `8` / `4`) %&gt;%\n  pivot_longer(names_to = \"comparisons\",\n               values_to = \"Fold_changes\",\n               time_8_vs_0:time_8_vs_4)\n\n# A tibble: 2,948 × 6\n# Groups:   gene [1,474]\n   gene         `0`     `4`     `8` comparisons Fold_changes\n   &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt;\n 1 AI504432 1034.   1104.   1014    time_8_vs_0        0.981\n 2 AI504432 1034.   1104.   1014    time_8_vs_4        0.918\n 3 AW046200  155.    152.     81    time_8_vs_0        0.522\n 4 AW046200  155.    152.     81    time_8_vs_4        0.532\n 5 AW551984  238     302.    342.   time_8_vs_0        1.44 \n 6 AW551984  238     302.    342.   time_8_vs_4        1.13 \n 7 Aamp     4603.   4870    4763.   time_8_vs_0        1.03 \n 8 Aamp     4603.   4870    4763.   time_8_vs_4        0.978\n 9 Abca12      5.29    4.25    4.14 time_8_vs_0        0.784\n10 Abca12      5.29    4.25    4.14 time_8_vs_4        0.975\n# ℹ 2,938 more rows"
  },
  {
    "objectID": "session-materials/session2/session2.html#joining-tables",
    "href": "session-materials/session2/session2.html#joining-tables",
    "title": "Session 2: Functions and Data Wrangling",
    "section": "Joining tables",
    "text": "Joining tables\nIn many real life situations, data are spread across multiple tables. Usually this occurs because different types of information are collected from different sources.\nIt may be desirable for some analyses to combine data from two or more tables into a single data frame based on a column that would be common to all the tables.\nThe dplyr package provides a set of join functions for combining two data frames based on matches within specified columns. Here, we provide a short introduction to joins. The Data Transformation Cheat Sheet also provides a short overview on table joins.\nWe are going to illustrate join using a small table, rna_mini that we will create by subsetting the original rna table, keeping only 3 columns and 10 lines.\n\nrna_mini &lt;- rna %&gt;%\n   select(gene, sample, expression) %&gt;%\n   head(10)\nrna_mini\n\n# A tibble: 10 × 3\n   gene    sample     expression\n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545336       1170\n 2 Apod    GSM2545336      36194\n 3 Cyp2d22 GSM2545336       4060\n 4 Klk6    GSM2545336        287\n 5 Fcrls   GSM2545336         85\n 6 Slc2a4  GSM2545336        782\n 7 Exd2    GSM2545336       1619\n 8 Gjc2    GSM2545336        288\n 9 Plp1    GSM2545336      43217\n10 Gnb4    GSM2545336       1071\n\n\nThe second table, annot1, contains 2 columns, gene and gene_description.\n\nannot1 &lt;- read_csv(file = \"data/annot1.csv\")\nannot1\n\n# A tibble: 10 × 2\n   gene    gene_description                                                     \n   &lt;chr&gt;   &lt;chr&gt;                                                                \n 1 Cyp2d22 cytochrome P450, family 2, subfamily d, polypeptide 22 [Source:MGI S…\n 2 Klk6    kallikrein related-peptidase 6 [Source:MGI Symbol;Acc:MGI:1343166]   \n 3 Fcrls   Fc receptor-like S, scavenger receptor [Source:MGI Symbol;Acc:MGI:19…\n 4 Plp1    proteolipid protein (myelin) 1 [Source:MGI Symbol;Acc:MGI:97623]     \n 5 Exd2    exonuclease 3'-5' domain containing 2 [Source:MGI Symbol;Acc:MGI:192…\n 6 Apod    apolipoprotein D [Source:MGI Symbol;Acc:MGI:88056]                   \n 7 Gnb4    guanine nucleotide binding protein (G protein), beta 4 [Source:MGI S…\n 8 Slc2a4  solute carrier family 2 (facilitated glucose transporter), member 4 …\n 9 Asl     argininosuccinate lyase [Source:MGI Symbol;Acc:MGI:88084]            \n10 Gjc2    gap junction protein, gamma 2 [Source:MGI Symbol;Acc:MGI:2153060]    \n\n\nWe now want to join these two tables into a single one containing all variables using the full_join() function from the dplyr package. The function will automatically find the common variable to match columns from the first and second table. In this case, gene is the common variable. Such variables are called keys. Keys are used to match observations across different tables.\n\nfull_join(rna_mini, annot1)\n\nJoining with `by = join_by(gene)`\n\n\n# A tibble: 10 × 4\n   gene    sample     expression gene_description                               \n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;                                          \n 1 Asl     GSM2545336       1170 argininosuccinate lyase [Source:MGI Symbol;Acc…\n 2 Apod    GSM2545336      36194 apolipoprotein D [Source:MGI Symbol;Acc:MGI:88…\n 3 Cyp2d22 GSM2545336       4060 cytochrome P450, family 2, subfamily d, polype…\n 4 Klk6    GSM2545336        287 kallikrein related-peptidase 6 [Source:MGI Sym…\n 5 Fcrls   GSM2545336         85 Fc receptor-like S, scavenger receptor [Source…\n 6 Slc2a4  GSM2545336        782 solute carrier family 2 (facilitated glucose t…\n 7 Exd2    GSM2545336       1619 exonuclease 3'-5' domain containing 2 [Source:…\n 8 Gjc2    GSM2545336        288 gap junction protein, gamma 2 [Source:MGI Symb…\n 9 Plp1    GSM2545336      43217 proteolipid protein (myelin) 1 [Source:MGI Sym…\n10 Gnb4    GSM2545336       1071 guanine nucleotide binding protein (G protein)…\n\n\nIn real life, gene annotations are sometimes labelled differently.\nThe annot2 table is exactly the same than annot1 except that the variable containing gene names is labelled differently.\n\nannot2 &lt;- read_csv(file = \"data/annot2.csv\")\n\nIn case none of the variable names match, we can set manually the variables to use for the matching. These variables can be set using the by argument, as shown below with rna_mini and annot2 tables.\n\nfull_join(rna_mini, annot2, by = c(\"gene\" = \"external_gene_name\"))\n\n# A tibble: 10 × 4\n   gene    sample     expression description                                    \n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;                                          \n 1 Asl     GSM2545336       1170 argininosuccinate lyase [Source:MGI Symbol;Acc…\n 2 Apod    GSM2545336      36194 apolipoprotein D [Source:MGI Symbol;Acc:MGI:88…\n 3 Cyp2d22 GSM2545336       4060 cytochrome P450, family 2, subfamily d, polype…\n 4 Klk6    GSM2545336        287 kallikrein related-peptidase 6 [Source:MGI Sym…\n 5 Fcrls   GSM2545336         85 Fc receptor-like S, scavenger receptor [Source…\n 6 Slc2a4  GSM2545336        782 solute carrier family 2 (facilitated glucose t…\n 7 Exd2    GSM2545336       1619 exonuclease 3'-5' domain containing 2 [Source:…\n 8 Gjc2    GSM2545336        288 gap junction protein, gamma 2 [Source:MGI Symb…\n 9 Plp1    GSM2545336      43217 proteolipid protein (myelin) 1 [Source:MGI Sym…\n10 Gnb4    GSM2545336       1071 guanine nucleotide binding protein (G protein)…\n\n\nAs can be seen above, the variable name of the first table is retained in the joined one.\n\n\n\n\n\n\nChallenge:\n\n\n\nLoad in the file annot3.csv. Using the full_join() function, join tables rna_mini and annot3. What has happened for genes Klk6, mt-Tf, mt-Rnr1, mt-Tv, mt-Rnr2, and mt-Tl1 ?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nannot3 &lt;- read_csv(\"data/annot3.csv\")\nfull_join(rna_mini, annot3)\n\n# A tibble: 15 × 4\n   gene    sample     expression gene_description                               \n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;                                          \n 1 Asl     GSM2545336       1170 argininosuccinate lyase [Source:MGI Symbol;Acc…\n 2 Apod    GSM2545336      36194 apolipoprotein D [Source:MGI Symbol;Acc:MGI:88…\n 3 Cyp2d22 GSM2545336       4060 cytochrome P450, family 2, subfamily d, polype…\n 4 Klk6    GSM2545336        287 &lt;NA&gt;                                           \n 5 Fcrls   GSM2545336         85 Fc receptor-like S, scavenger receptor [Source…\n 6 Slc2a4  GSM2545336        782 solute carrier family 2 (facilitated glucose t…\n 7 Exd2    GSM2545336       1619 exonuclease 3'-5' domain containing 2 [Source:…\n 8 Gjc2    GSM2545336        288 gap junction protein, gamma 2 [Source:MGI Symb…\n 9 Plp1    GSM2545336      43217 proteolipid protein (myelin) 1 [Source:MGI Sym…\n10 Gnb4    GSM2545336       1071 guanine nucleotide binding protein (G protein)…\n11 mt-Tf   &lt;NA&gt;               NA mitochondrially encoded tRNA phenylalanine [So…\n12 mt-Rnr1 &lt;NA&gt;               NA mitochondrially encoded 12S rRNA [Source:MGI S…\n13 mt-Tv   &lt;NA&gt;               NA mitochondrially encoded tRNA valine [Source:MG…\n14 mt-Rnr2 &lt;NA&gt;               NA mitochondrially encoded 16S rRNA [Source:MGI S…\n15 mt-Tl1  &lt;NA&gt;               NA mitochondrially encoded tRNA leucine 1 [Source…\n\n\nGenes Klk6 is only present in rna_mini, while genes mt-Tf, mt-Rnr1, mt-Tv, mt-Rnr2, and mt-Tl1 are only present in annot3 table. Their respective values for the variables of the table have been encoded as missing."
  },
  {
    "objectID": "session-materials/session2/session2.html#exporting-data",
    "href": "session-materials/session2/session2.html#exporting-data",
    "title": "Session 2: Functions and Data Wrangling",
    "section": "Exporting data",
    "text": "Exporting data\nNow that you have learned how to use dplyr to extract information from or summarise your raw data, you may want to export these new data sets to share them with your collaborators or for archival.\nSimilar to the read_csv() function used for reading CSV files into R, there is a write_csv() function that generates CSV files from data frames.\nBefore using write_csv(), we are going to create a new folder, data_output, in our working directory that will store this generated dataset. We don’t want to write generated datasets in the same directory as our raw data. It’s good practice to keep them separate. The data folder should only contain the raw, unaltered data, and should be left alone to make sure we don’t delete or modify it. In contrast, our script will generate the contents of the data_output directory, so even if the files it contains are deleted, we can always re-generate them.\nLet’s use write_csv() to save the rna_wide table that we have created previously.\n\nwrite_csv(rna_wide, file = \"data_output/rna_wide.csv\")\n\n\nThe materials in this lesson have been adapted from work created by the (HBC)](http://bioinformatics.sph.harvard.edu/) and Data Carpentry (http://datacarpentry.org/), as well as materials created by Laurent Gatto, Charlotte Soneson, Jenny Drnevich, Robert Castelo, and Kevin Rue-Albert. These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited."
  },
  {
    "objectID": "session-materials/sessions.html",
    "href": "session-materials/sessions.html",
    "title": "Sessions",
    "section": "",
    "text": "Sessions\nThis set of pages contains the in-class materials we will be using.\nYou can browse the materials for each Session on this website, but for class you need to download these materials and datasets.\n\nSession 1: Getting started with R\nDownload Session 1 Materials Here\n\n\nSession 2: Functions and Data Wrangling\nDownload Session 2 Materials Here\n\n\nSession 3: Data Exploration & Visualization\nDownload Session 4 Materials Here\n\n\nSession 4: Modeling\nDownload Session 4 Materials Here"
  },
  {
    "objectID": "session-materials/session1/session1.html",
    "href": "session-materials/session1/session1.html",
    "title": "Session 1: R Basics",
    "section": "",
    "text": "Session 1 materials go here"
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "Licenses",
    "section": "",
    "text": "All Software Carpentry, Data Carpentry, and Library Carpentry instructional material is made available under the Creative Commons Attribution license. The following is a human-readable summary of (and not a substitute for) the full legal text of the CC BY 4.0 license.\nYou are free:\n\nto Share—copy and redistribute the material in any medium or format\nto Adapt—remix, transform, and build upon the material\n\nfor any purpose, even commercially.\nThe licensor cannot revoke these freedoms as long as you follow the license terms.\nUnder the following terms:\n\nAttribution—You must give appropriate credit (mentioning that your work is derived from work that is Copyright © Software Carpentry and, where practical, linking to http://software-carpentry.org/), provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.\n\nNo additional restrictions—You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits. With the understanding that:\nNotices:\n\nYou do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation.\nNo warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material."
  },
  {
    "objectID": "LICENSE.html#instructional-material",
    "href": "LICENSE.html#instructional-material",
    "title": "Licenses",
    "section": "",
    "text": "All Software Carpentry, Data Carpentry, and Library Carpentry instructional material is made available under the Creative Commons Attribution license. The following is a human-readable summary of (and not a substitute for) the full legal text of the CC BY 4.0 license.\nYou are free:\n\nto Share—copy and redistribute the material in any medium or format\nto Adapt—remix, transform, and build upon the material\n\nfor any purpose, even commercially.\nThe licensor cannot revoke these freedoms as long as you follow the license terms.\nUnder the following terms:\n\nAttribution—You must give appropriate credit (mentioning that your work is derived from work that is Copyright © Software Carpentry and, where practical, linking to http://software-carpentry.org/), provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.\n\nNo additional restrictions—You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits. With the understanding that:\nNotices:\n\nYou do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation.\nNo warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material."
  },
  {
    "objectID": "LICENSE.html#software",
    "href": "LICENSE.html#software",
    "title": "Licenses",
    "section": "Software",
    "text": "Software\nExcept where otherwise noted, the example programs and other software provided by Software Carpentry and Data Carpentry are made available under the OSI-approved MIT license.\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "LICENSE.html#trademark",
    "href": "LICENSE.html#trademark",
    "title": "Licenses",
    "section": "Trademark",
    "text": "Trademark\n“Software Carpentry” and “Data Carpentry” and their respective logos are registered trademarks of Community Initiatives."
  },
  {
    "objectID": "resources/getting-help.html",
    "href": "resources/getting-help.html",
    "title": "Where to get help",
    "section": "",
    "text": "Where to get help\n\nUse the built-in RStudio help interface to search for more information on R functions\n\n\n\n\n\nRStudio help interface.\n\n\n\n\nOne of the fastest ways to get help, is to use the RStudio help interface. This panel by default can be found at the lower right hand panel of RStudio. As seen in the screenshot, by typing the word “Mean”, RStudio tries to also give a number of suggestions that you might be interested in. The description is then shown in the display window.\n\n\nI know the name of the function I want to use, but I’m not sure how to use it\nIf you need help with a specific function, let’s say barplot(), you can type:\n\n?barplot\n\nIf you just need to remind yourself of the names of the arguments, you can use:\n\nargs(lm)\n\n\n\nI want to use a function that does X, there must be a function for it but I don’t know which one…\nIf you are looking for a function to do a particular task, you can use the help.search() function, which is called by the double question mark ??. However, this only looks through the installed packages for help pages with a match to your search request\n\n??kruskal\n\nIf you can’t find what you are looking for, you can use the rdocumentation.org website that searches through the help files across all packages available.\nFinally, a generic Google or internet search “R &lt;task&gt;” will often either send you to the appropriate package documentation or a helpful forum where someone else has already asked your question.\n\n\nI am stuck… I get an error message that I don’t understand\nStart by googling the error message. However, this doesn’t always work very well because often, package developers rely on the error catching provided by R. You end up with general error messages that might not be very helpful to diagnose a problem (e.g. “subscript out of bounds”). If the message is very generic, you might also include the name of the function or package you’re using in your query.\nHowever, you should check Stack Overflow. Search using the [r] tag. Most questions have already been answered, but the challenge is to use the right words in the search to find the answers:\nhttp://stackoverflow.com/questions/tagged/r\nThe Introduction to R can also be dense for people with little programming experience but it is a good place to understand the underpinnings of the R language.\nThe R FAQ is dense and technical but it is full of useful information.\n\n\nAsking for help\nThe key to receiving help from someone is for them to rapidly grasp your problem. You should make it as easy as possible to pinpoint where the issue might be.\nTry to use the correct words to describe your problem. For instance, a package is not the same thing as a library. Most people will understand what you meant, but others have really strong feelings about the difference in meaning. The key point is that it can make things confusing for people trying to help you. Be as precise as possible when describing your problem.\nIf possible, try to reduce what doesn’t work to a simple reproducible example. If you can reproduce the problem using a very small data frame instead of your 50000 rows and 10000 columns one, provide the small one with the description of your problem. When appropriate, try to generalise what you are doing so even people who are not in your field can understand the question. For instance instead of using a subset of your real dataset, create a small (3 columns, 5 rows) generic one. For more information on how to write a reproducible example see this article by Hadley Wickham.\nTo share an object with someone else, if it’s relatively small, you can use the function dput(). It will output R code that can be used to recreate the exact same object as the one in memory:\n\n## iris is an example data frame that comes with R and head() is a\n## function that returns the first part of the data frame\ndput(head(iris))\n\nstructure(list(Sepal.Length = c(5.1, 4.9, 4.7, 4.6, 5, 5.4), \n    Sepal.Width = c(3.5, 3, 3.2, 3.1, 3.6, 3.9), Petal.Length = c(1.4, \n    1.4, 1.3, 1.5, 1.4, 1.7), Petal.Width = c(0.2, 0.2, 0.2, \n    0.2, 0.2, 0.4), Species = structure(c(1L, 1L, 1L, 1L, 1L, \n    1L), levels = c(\"setosa\", \"versicolor\", \"virginica\"), class = \"factor\")), row.names = c(NA, \n6L), class = \"data.frame\")\n\n\nIf the object is larger, provide either the raw file (i.e., your CSV file) with your script up to the point of the error (and after removing everything that is not relevant to your issue). Alternatively, in particular if your question is not related to a data frame, you can save any R object to a file[^export]:\n\nsaveRDS(iris, file=\"/tmp/iris.rds\")\n\nThe content of this file is however not human readable and cannot be posted directly on Stack Overflow. Instead, it can be sent to someone by email who can read it with the readRDS() command (here it is assumed that the downloaded file is in a Downloads folder in the user’s home directory):\n\nsome_data &lt;- readRDS(file=\"~/Downloads/iris.rds\")\n\nLast, but certainly not least, always include the output of sessionInfo() as it provides critical information about your platform, the versions of R and the packages that you are using, and other information that can be very helpful to understand your problem.\n\nsessionInfo()\n\nR version 4.3.0 (2023-04-21)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.5\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/New_York\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.2 compiler_4.3.0    fastmap_1.1.1     cli_3.6.1        \n [5] tools_4.3.0       htmltools_0.5.5   rstudioapi_0.15.0 rmarkdown_2.23   \n [9] knitr_1.43        jsonlite_1.8.7    xfun_0.39         digest_0.6.33    \n[13] rlang_1.1.1       evaluate_0.21    \n\n\n\n\nWhere to ask for help?\n\nThe person sitting next to you. Don’t hesitate to talk to your neighbour during the workshop, compare your answers, and ask for help.\nThe instructors. We’re here to help you.\nYour friendly colleagues: if you know someone with more experience than you, they might be able and willing to help you.\nStack Overflow: if your question hasn’t been answered before and is well crafted, chances are you will get an answer in less than 5 min. Remember to follow their guidelines on how to ask a good question.\nThe R-help mailing list: it is read by a lot of people (including most of the R core team), a lot of people post to it, but the tone can be pretty dry, and it is not always very welcoming to new users. If your question is valid, you are likely to get an answer very fast but don’t expect that it will come with smiley faces. Also, here more than anywhere else, be sure to use correct vocabulary (otherwise you might get an answer pointing to the misuse of your words rather than answering your question). You will also have more success if your question is about a base function rather than a specific package.\nIf your question is about a specific package, see if there is a mailing list for it. Usually it’s included in the DESCRIPTION file of the package that can be accessed using packageDescription(\"name-of-package\"). You may also want to try to email the author of the package directly, or open an issue on the code repository (e.g., GitHub).\nThere are also some topic-specific mailing lists (GIS, phylogenetics, etc…), the complete list is here.\n\n\n\nMore resources\n\nThe Posting Guide for the R mailing lists.\nHow to ask for R help useful guidelines.\nThis blog post by Jon Skeet has quite comprehensive advice on how to ask programming questions.\nThe reprex package is very helpful to create reproducible examples when asking for help. The rOpenSci community call “How to ask questions so they get answered” (Github link and video recording) includes a presentation of the reprex package and of its philosophy.\n\n\nThe materials in this lesson have been adapted from the Introduction to data analysis with R and Bioconductor workshop, which is a part of the Carpentries Incubator. These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited."
  },
  {
    "objectID": "resources/install.html",
    "href": "resources/install.html",
    "title": "Installing R and RStudio",
    "section": "",
    "text": "Open an internet browser and go to www.r-project.org.\nClick the “download R” link in the middle of the page under “Getting Started.”\nSelect a CRAN location (a mirror site) and click the corresponding link.\nClick on the “Download R for (Mac) OS X” link at the top of the page.\nClick on the file containing the latest version of R under “Files.”\nSave the .pkg file, double-click it to open, and follow the installation instructions.\nNow that R is installed, you need to download and install RStudio.\n\n\n\n\n\nGo to www.rstudio.com and click on the “Download RStudio” button.\nClick on “DOWNLOAD” in the upper right corner.\nDownload the Free version of RStudio Desktop.\nSave the .dmg file on your computer, double-click it to open, and then drag and drop it to your applications folder.\n\n\n\n\n\n\n\n\nOpen an internet browser and go to www.r-project.org.\nClick the “download R” link in the middle of the page under “Getting Started.”\nSelect a CRAN location (a mirror site) and click the corresponding link.\nClick on the “Download R for Windows” link at the top of the page.\nClick on the “install R for the first time” link at the top of the page.\nClick “Download R for Windows” and save the executable file somewhere on your computer. Run the .exe file and follow the installation instructions.\nNow that R is installed, you need to download and install RStudio.\n\n\n\n\n\nGo to www.rstudio.com and click on the “Download RStudio” button.\nClick on “DOWNLOAD” in the upper right corner.\nDownload the Free version of RStudio Desktop.\nSave the executable file. Run the .exe file and follow the installation instructions.\n\nPermissions\nNote that you should install R and RStudio to a drive where you have read and write permissions. Otherwise, your ability to install R packages (a frequent occurrence) will be impacted. If you encounter problems, try opening RStudio by right-clicking the icon and selecting “Run as administrator”. Other tips can be found in the page [R on network drives].\nHow to update R and RStudio\nYour version of R is printed to the R Console at start-up. You can also run sessionInfo().\nTo update R, go to the website mentioned above and re-install R. Be aware that the old R version will still exist in your computer. You can temporarily run an older version (older “installation”) of R by clicking “Tools” -&gt; “Global Options” in RStudio and choosing an R version. This can be useful if you want to use a package that has not been updated to work on the newest version of R.\nTo update RStudio, you can go to the website above and re-download RStudio. Another option is to click “Help” -&gt; “Check for Updates” within RStudio, but this may not show the very latest updates.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInstructions adapted from guide developed by HMS Research computing and Chapter 3 of the The Epidemiologist R Handbook."
  },
  {
    "objectID": "resources/install.html#mac-users",
    "href": "resources/install.html#mac-users",
    "title": "Installing R and RStudio",
    "section": "",
    "text": "Open an internet browser and go to www.r-project.org.\nClick the “download R” link in the middle of the page under “Getting Started.”\nSelect a CRAN location (a mirror site) and click the corresponding link.\nClick on the “Download R for (Mac) OS X” link at the top of the page.\nClick on the file containing the latest version of R under “Files.”\nSave the .pkg file, double-click it to open, and follow the installation instructions.\nNow that R is installed, you need to download and install RStudio.\n\n\n\n\n\nGo to www.rstudio.com and click on the “Download RStudio” button.\nClick on “DOWNLOAD” in the upper right corner.\nDownload the Free version of RStudio Desktop.\nSave the .dmg file on your computer, double-click it to open, and then drag and drop it to your applications folder."
  },
  {
    "objectID": "resources/install.html#windows-users",
    "href": "resources/install.html#windows-users",
    "title": "Installing R and RStudio",
    "section": "",
    "text": "Open an internet browser and go to www.r-project.org.\nClick the “download R” link in the middle of the page under “Getting Started.”\nSelect a CRAN location (a mirror site) and click the corresponding link.\nClick on the “Download R for Windows” link at the top of the page.\nClick on the “install R for the first time” link at the top of the page.\nClick “Download R for Windows” and save the executable file somewhere on your computer. Run the .exe file and follow the installation instructions.\nNow that R is installed, you need to download and install RStudio.\n\n\n\n\n\nGo to www.rstudio.com and click on the “Download RStudio” button.\nClick on “DOWNLOAD” in the upper right corner.\nDownload the Free version of RStudio Desktop.\nSave the executable file. Run the .exe file and follow the installation instructions.\n\nPermissions\nNote that you should install R and RStudio to a drive where you have read and write permissions. Otherwise, your ability to install R packages (a frequent occurrence) will be impacted. If you encounter problems, try opening RStudio by right-clicking the icon and selecting “Run as administrator”. Other tips can be found in the page [R on network drives].\nHow to update R and RStudio\nYour version of R is printed to the R Console at start-up. You can also run sessionInfo().\nTo update R, go to the website mentioned above and re-install R. Be aware that the old R version will still exist in your computer. You can temporarily run an older version (older “installation”) of R by clicking “Tools” -&gt; “Global Options” in RStudio and choosing an R version. This can be useful if you want to use a package that has not been updated to work on the newest version of R.\nTo update RStudio, you can go to the website above and re-download RStudio. Another option is to click “Help” -&gt; “Check for Updates” within RStudio, but this may not show the very latest updates."
  },
  {
    "objectID": "resources/install.html#reference",
    "href": "resources/install.html#reference",
    "title": "Installing R and RStudio",
    "section": "",
    "text": "Instructions adapted from guide developed by HMS Research computing and Chapter 3 of the The Epidemiologist R Handbook."
  },
  {
    "objectID": "resources/quarto-reports.html",
    "href": "resources/quarto-reports.html",
    "title": "Quarto and RMarkdown",
    "section": "",
    "text": "Quarto and RMarkdown\nR Markdown is a widely-used tool for creating automated, reproducible, and share-worthy outputs, such as reports. It can generate static or interactive outputs, in Word, pdf, html, powerpoint, and other formats.\nAn R Markdown script intersperces R code and text such that the script actually becomes your output document. You can create an entire formatted document, including narrative text (can be dynamic to change based on your data), tables, figures, bullets/numbers, bibliographies, etc.\nBelow is very upbeat 1 minute video defining R Markdown, taken from an official beginner’s guide by the creators of RStudio.\n\nThe guide is a great resource for understanding what R Markdown is.\nQuarto is the new R Markdown put out by Posit, the makers of RStudio (and formerly named RStudio Inc.). You can find a quick tutorial on Quarto here\nR for Data Science also has a great chapter on Quarto.\nThis entire website and all materials are written in Quarto."
  },
  {
    "objectID": "resources/resources.html",
    "href": "resources/resources.html",
    "title": "Additional Resources",
    "section": "",
    "text": "Help documentation\nSearch the RStudio “Help” tab for documentation on R packages and specific functions. This is within the pane that also contains Files, Plots, and Packages (typically in the lower-right pane). As a shortcut, you can also type the name of a package or function into the R console after a question-mark to open the relevant Help page. Do not include parentheses.\nFor example: ?filter or ?diagrammeR.\nInteractive tutorials\nThere are several ways to learn R interactively within RStudio.\nRStudio itself offers a Tutorial pane that is powered by the learnr R package. Simply install this package and open a tutorial via the new “Tutorial” tab in the upper-right RStudio pane (which also contains Environment and History tabs).\nThe R package swirl offers interactive courses in the R Console. Install and load this package, then run the command swirl() (empty parentheses) in the R console. You will see prompts appear in the Console. Respond by typing in the Console. It will guide you through a course of your choice.\n\n\n\nThere are many PDF “cheatsheets” available on the RStudio website, for example:\n\nFactors with forcats package\n\nDates and times with lubridate package\n\nStrings with stringr package\n\niterative opertaions with purrr package\n\nData import\n\nData transformation cheatsheet with dplyr package\n\nR Markdown (to create documents like PDF, Word, Powerpoint…)\n\nShiny (to build interactive web apps)\n\nData visualization with ggplot2 package\n\nCartography (GIS)\n\nleaflet package (interactive maps)\n\nPython with R (reticulate package)\n\nThis is an online R resource specifically for Excel users\n\n\n\n\n\n\nThe definitive R Markdown guide\n\n\n\n\n\nSome great lecture slides on data visualization\nanother plotting cheat sheet\ntidyverse ggplot basics page\n\nplotting continuous variables\n\nR for Data Science pages on data visualization\ngraphics for communicaton\n\n\n\n\n\n\nThe full flextable book is here: https://ardata-fr.github.io/flextable-book/\nThe Github site is here\n\nA manual of all the flextable functions can be found here\nA gallery of beautiful example flextable tables with code can be accessed here\n\n\n\n\nThe Data Carpentry page on dplyr\n\nThe tidyverse reference pages on group_by() and grouping\n\nThis page on Data manipulation\n\nSummarize with conditions in dplyr\n\nA helpful tutorial on pivoting tutorial\nThe tidyverse page on joins\n\nThe R for Data Science page on relational data\n\n\n\n\n\nLecture slides on surveys\nUCLA stats page\n\nArticle by Pew research for a general audeince on why we use survey weights\n\n\n\n\n\n\n\nR has a vibrant twitter community where you can learn tips, shortcuts, and news - follow these accounts:\n\nEpiHandbook (makers of the textbook these materials are based on) @epiRhandbook\n\nR Function A Day @rfuntionaday is an incredible resource\n\nR for Data Science @rstats4ds\n\nRStudio @RStudio\n\nRStudio Tips @rstudiotips\n\nR-Bloggers @Rbloggers\n\nR-ladies @RLadiesGlobal\n\nHadley Wickham @hadleywickham\n\nAlso:\n#epitwitter and #rstats\n\n\n\nA definitive text is the R for Data Science book by Garrett Grolemund and Hadley Wickham\nThe R4Epis project website aims to “develop standardised data cleaning, analysis and reporting tools to cover common types of outbreaks and population-based surveys that would be conducted in an MSF emergency response setting.” You can find R basics training materials, templates for RMarkdown reports on outbreaks and surveys, and tutorials to help you set them up.\n\n\n\n\nMateriales de RStudio en Español\nIntroduction à R et au tidyverse (Francais)"
  },
  {
    "objectID": "resources/resources.html#other-r-resources",
    "href": "resources/resources.html#other-r-resources",
    "title": "Additional Resources",
    "section": "",
    "text": "Help documentation\nSearch the RStudio “Help” tab for documentation on R packages and specific functions. This is within the pane that also contains Files, Plots, and Packages (typically in the lower-right pane). As a shortcut, you can also type the name of a package or function into the R console after a question-mark to open the relevant Help page. Do not include parentheses.\nFor example: ?filter or ?diagrammeR.\nInteractive tutorials\nThere are several ways to learn R interactively within RStudio.\nRStudio itself offers a Tutorial pane that is powered by the learnr R package. Simply install this package and open a tutorial via the new “Tutorial” tab in the upper-right RStudio pane (which also contains Environment and History tabs).\nThe R package swirl offers interactive courses in the R Console. Install and load this package, then run the command swirl() (empty parentheses) in the R console. You will see prompts appear in the Console. Respond by typing in the Console. It will guide you through a course of your choice.\n\n\n\nThere are many PDF “cheatsheets” available on the RStudio website, for example:\n\nFactors with forcats package\n\nDates and times with lubridate package\n\nStrings with stringr package\n\niterative opertaions with purrr package\n\nData import\n\nData transformation cheatsheet with dplyr package\n\nR Markdown (to create documents like PDF, Word, Powerpoint…)\n\nShiny (to build interactive web apps)\n\nData visualization with ggplot2 package\n\nCartography (GIS)\n\nleaflet package (interactive maps)\n\nPython with R (reticulate package)\n\nThis is an online R resource specifically for Excel users\n\n\n\n\n\n\nThe definitive R Markdown guide\n\n\n\n\n\nSome great lecture slides on data visualization\nanother plotting cheat sheet\ntidyverse ggplot basics page\n\nplotting continuous variables\n\nR for Data Science pages on data visualization\ngraphics for communicaton\n\n\n\n\n\n\nThe full flextable book is here: https://ardata-fr.github.io/flextable-book/\nThe Github site is here\n\nA manual of all the flextable functions can be found here\nA gallery of beautiful example flextable tables with code can be accessed here\n\n\n\n\nThe Data Carpentry page on dplyr\n\nThe tidyverse reference pages on group_by() and grouping\n\nThis page on Data manipulation\n\nSummarize with conditions in dplyr\n\nA helpful tutorial on pivoting tutorial\nThe tidyverse page on joins\n\nThe R for Data Science page on relational data\n\n\n\n\n\nLecture slides on surveys\nUCLA stats page\n\nArticle by Pew research for a general audeince on why we use survey weights\n\n\n\n\n\n\n\nR has a vibrant twitter community where you can learn tips, shortcuts, and news - follow these accounts:\n\nEpiHandbook (makers of the textbook these materials are based on) @epiRhandbook\n\nR Function A Day @rfuntionaday is an incredible resource\n\nR for Data Science @rstats4ds\n\nRStudio @RStudio\n\nRStudio Tips @rstudiotips\n\nR-Bloggers @Rbloggers\n\nR-ladies @RLadiesGlobal\n\nHadley Wickham @hadleywickham\n\nAlso:\n#epitwitter and #rstats\n\n\n\nA definitive text is the R for Data Science book by Garrett Grolemund and Hadley Wickham\nThe R4Epis project website aims to “develop standardised data cleaning, analysis and reporting tools to cover common types of outbreaks and population-based surveys that would be conducted in an MSF emergency response setting.” You can find R basics training materials, templates for RMarkdown reports on outbreaks and surveys, and tutorials to help you set them up.\n\n\n\n\nMateriales de RStudio en Español\nIntroduction à R et au tidyverse (Francais)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Systems Immunology Bootcamp",
    "section": "",
    "text": "Instructor learning materials for data analysis module of Research Design and Analysis, 2023."
  },
  {
    "objectID": "index.html#schedule",
    "href": "index.html#schedule",
    "title": "Systems Immunology Bootcamp",
    "section": "Schedule",
    "text": "Schedule"
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Systems Immunology Bootcamp",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThe zoom link will not be presented on this website since it is public. Please email Chris or Eren if you can’t find the Zoom information.↩︎"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "problem-sets/problem-sets.html",
    "href": "problem-sets/problem-sets.html",
    "title": "Problem Sets",
    "section": "",
    "text": "Problem Sets\nThis is where problem sets will live."
  }
]